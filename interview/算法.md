## 排序算法

### 冒泡排序

- 代码实现

  ```java
  /**
   * @Auther:zwer
   * @Date:2019/12/30 15:49
   * @Description:com.szxy.sort.bubble
   * @Version:1.0
   * 冒泡排序
   * 时间复杂度: o(n^2)
   **/
  public class BubbleSortDemo {
      public void bubbleSort(int[] arr) {
  
          // 外层循环控制每次数组循环的次数
          for (int i = 0; i < arr.length; i++) {
              boolean flag = true; // 优化，若已经有序，则直接跳出循环
              // 内层循环控制每次循环元素间比较的次数
              for (int j = 0; j < arr.length - 1 - i; j++) {
                  if (arr[j] > arr[j + 1]) {
                      int temp = arr[j];
                      arr[j] = arr[j + 1];
                      arr[j + 1] = temp;
                      flag = false;
                  }
              }
              System.out.println("temp: " + i + " " + Arrays.toString(arr));
  
              if (flag) break;  //跳出循环
  
          }
  
      }
  
      @Test
      public void testBubbleSort() {
          int[] arr = new int[]{5, 2, 6, 9, 0, 3};
          System.out.println(Arrays.toString(arr));
          bubbleSort(arr);
          System.out.println(Arrays.toString(arr));
      }
  }
  
  ```

  

### 快速排序（简称快排）

> 采用分而治之的思想

- 快速排序的原理

  给定一组数据，选取一个分区点（prvot）作为中间值，比分区点值大的放在右边，比分区点值小的放在左边，然后再对左边和右边选取新的分区点，继续再原来的方式排列，直到所有数组按顺序排列大小为止

- 代码实现

  ```java
	package com.szxy.sort;
    import java.util.Arrays;
  
  /**
       * @Auther:zwer
       * @Date:2019/12/29 20:42
       * @Description:com.szxy.sort
       * @Version:1.0 快速排序
       * 最好情况时间复杂度为 O(n2)，最坏情况时间复杂度为:O(n2)，平均情况下的时间复杂度为：O(n2)。
       * 空间复杂度为 O(1)，是一个 in-place序算法
          **/
  
  public class QuickSortTest {
      /**
           * 快速排序
           * @param arr
           * @param start
           * @param end
           */
      public void quickSort(int[] arr, int start, int end) {
          // 递归出口
          if(arr.length <= 1 || start >end) return;
          int pivotIndex = partition(arr, start, end);
          // 左分区
          quickSort(arr,start,pivotIndex-1);
          // 右分区
          quickSort(arr,pivotIndex+1, end);
      }
  
      // 分区
      public int partition(int[] arr, int start, int end) {
          // 选取 end 位置作为默认的分区点
          int pivot = arr[end];
          // 寻找分区点对应的索引下标
          int pivotIndex = start;
          for (int i = start; i < end; i++) {
              if(arr[i] < pivot){
                  if(i > pivotIndex){
                      swap(arr,i,pivotIndex);
                  }
                  pivotIndex++;
              }
              //System.out.println(Arrays.toString(arr));
          }
          swap(arr,end,pivotIndex);
  
          return pivotIndex;
      }
  
      /**
           * 数值交互
           *
           * @param arr
           * @param i
           * @param j
           */
      public void swap(int[] arr, int i, int j) {
          int temp = arr[j];
          arr[j] = arr[i];
          arr[i] = temp;
      }
      /**
           * 测试
           *
           * @param args
           */
      public static void main(String[] args) {
          int[] arr = new int[]{0, 3, 5, 7, 2, 4, 9, 6};
          System.out.println(Arrays.toString(arr));
          new QuickSortTest().quickSort(arr, 0, arr.length-1);
          System.out.println(Arrays.toString(arr));
      }
  
  }

  ```

  

### 归并排序算法

- 归并排序思想

  采用分而治之的方法

  第一步：拆分(采用递归的方式拆分)

  第二步：合并（采用合并两个有序数组的方式合并）

- 代码实现

  ```java
  
  /**
   * 归并排序算法
   *  归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，
   然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了
   */
  public class MergeSort {
      public int[] mergeSort(int[] arr){
  
          if (arr.length<2){
              return  arr;
          }
          //将我们的数组拆分成两个部分
  
          int mid = arr.length/2;
          int [] left = Arrays.copyOfRange(arr,0,mid);
          int [] right = Arrays.copyOfRange(arr,mid,arr.length);
  
          //  分解并合并
          return merge(mergeSort(left),mergeSort(right));
  
  
      }
      /**
       * 合并两个有序数组并返回新的数组
       * @param left
       * @param right
       */
      public int[] merge(int[] left,int[] right){
  
          // 创建一个新的数组，这个数组的长度等于两个数组长度之和
          int [] newArray = new int[left.length+right.length];
          //  定义两个指针分别代表两个数组的下标
          int lindex = 0;
          int rindex = 0;
          for (int i=0; i< newArray.length;i++){
              if (lindex>=left.length){
                  newArray[i]=right[rindex++];
              } else  if (rindex>=right.length){
                  newArray[i] =left[lindex++];
              } else if(left[lindex] <right[rindex]){
                  newArray[i] = left[lindex++];
              } else {
                  newArray[i] = right[rindex++];
              }
          }
          return  newArray;
      }
  
  
      @Test
      public void testInsertionSort1(){
          //准备一个int数组
          int[] array = new int[6];
          array[0] = 5;
          array[1] = 2;
          array[2] = 6;
          array[3] = 9;
          array[4] = 0;
          array[5] = 3;
          //进行排序
          System.out.println(Arrays.toString(array));
          array = mergeSort(array);
          //输出排序结果
          System.out.println(Arrays.toString(array));
      }
  }
  ```

