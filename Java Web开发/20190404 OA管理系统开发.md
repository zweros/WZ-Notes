---
title: 20190404 OA管理系统开发
date: 2019-04-04
categories: ['后端']
tags: ['OA系统']
---



# 1 项目概况

> 

# 2 搭建项目框架

1 设置工作空间的编码，设置 workspace 的编码为 utf-8

2  创建包和文件，注意可以不同文件夹创建相同的包，但是不能建相同类名的类

​	system 人事 、 duty 、 expense  、 inout 收支

3 导入 jar 包 和 工具类以及配置文件 

4 导入 SQL 脚本



# 3 部门模块

## 3.1 Junit 测试 

> 使用注解` @Test `进行测试
>
> ​		        `@ignore `取消该方法的测试
>
> 建议测试方法名`testMethod()`



## 3.2  重定向和请求转发

> 建议在提交表单后，使用重定向，防止表单重复提交，保护第一次请求数据。

```java
this.getContextPath()  //动态获取上下文路径
```



## 3.3 断点调试

> 在 servlet 中，设置断点，然后在客户端执行相应的操作，查看代码的运行过程。

1. 以 dubug 模式开启 server 服务器
2. 设置断点
3. 查看运行过程



## 3.3 时序图

### 3.3.1 添加部门信息

![](http://www.zwer.xyz/picGo/20190404213006.png)



### 3.3.2 部门信息更新操作

```sequence
title: 更新操作

participant deptList.jsp
participant deptUpdate.jsp



DeparmentServlet -> DepartmentService:调用 findDeptById(req,resp)方法
DepartmentService -> DepartmentDao:调用 findDeptById(int deptno)方法
DepartmentDao -> DBUtil:调用 findDeptById(int deptno)方法



DBUtil - > DepartmentDao: return dept
DepartmentDao -> DepartmentService: return dept 
DepartmentService-> DeparmentServlet: return dept 
DeparmentServlet -> deptUpdate.jsp:显示

deptUpdate.jsp -> DeparmentServlet: 发送请求update(Department dept)
DeparmentServlet ->DepartmentService: 调用update(Department dept)
DepartmentService -> DepartmentDao:调用 update(Department dept) 
DepartmentDao->DBUtil:调用 update(Department dept) 


DBUtil - > DepartmentDao: return dept
DepartmentDao -> DepartmentService: return dept 
DepartmentService-> DeparmentServlet: return dept 
DeparmentServlet -> deptList.jsp:显示

```

## 3.4  属性关联

> 用于实体类一对多关系
>
> 将表中的外键关系，在 java 语言用 类与类之间的关系表表示
>
> new  java.sql.Date(().getTime);
>
> 如何表示员工所属一个部门、一个岗位、一个上级、甚至多个下级的信息？
>
> 在数据库中通过外键来实现： deptno、posid、mgrid
>
> 在 Java 类中通过属性关联来实现，即通过添加类有私有属性完成。

 

```java
package com.szxy.pojo;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * 一对多的联系
 * 在 Java 类中通过属性关联的方式实现
 * 
 * 	private Department dept;// 所在部门的信息
	private Position pos; //所在岗位的信息
	private Employee mgr; //上级领导
	private List<Employee> empList = new ArrayList<>(); //下级员工
 *
 */
public class Employee {
	private String empId;
	private String passWord;
	private String realName;
	private String sex;
	private Date birthDate; //出生日期
	private Date hireDate;  //入职日期
	private Date leaveDate; //离职日期
	private int onduty; //   0-离职  1-在职         
	private int emptype;//   1.普通员工  2.管理人员 含经理、总监、总裁等  3.管理员 	
	private String phone;
	private String qq;
	private String emerContactPerson;//紧急联系人
	private String idCard; // 身份证号
	private Department dept;// 所在部门的信息
	private Position pos; //所在岗位的信息
	private Employee mgr; //上级领导
	private List<Employee> empList = new ArrayList<>(); //下级员工
	public Employee() {
		super();
	}
	public Employee(String empId, String passWord, String realName, String sex,
			Date birthDate, Date hireDate, Date leaveDate, int onduty,
			int emptype, String phone, String qq, String emerContactPerson,
			String idCard, Department dept, Position pos, Employee mgr,
			List<Employee> empList) {
		super();
		this.empId = empId;
		this.passWord = passWord;
		this.realName = realName;
		this.sex = sex;
		this.birthDate = birthDate;
		this.hireDate = hireDate;
		this.leaveDate = leaveDate;
		this.onduty = onduty;
		this.emptype = emptype;
		this.phone = phone;
		this.qq = qq;
		this.emerContactPerson = emerContactPerson;
		this.idCard = idCard;
		this.dept = dept;
		this.pos = pos;
		this.mgr = mgr;
		this.empList = empList;
	}
	public Employee(String empId, String passWord, String realName, String sex,
			Date birthDate, Date hireDate, Date leaveDate, int onduty,
			int emptype, String phone, String qq, String emerContactPerson,
			String idCard, Department dept, Position pos, Employee mgr) {
		super();
		this.empId = empId;
		this.passWord = passWord;
		this.realName = realName;
		this.sex = sex;
		this.birthDate = birthDate;
		this.hireDate = hireDate;
		this.leaveDate = leaveDate;
		this.onduty = onduty;
		this.emptype = emptype;
		this.phone = phone;
		this.qq = qq;
		this.emerContactPerson = emerContactPerson;
		this.idCard = idCard;
		this.dept = dept;
		this.pos = pos;
		this.mgr = mgr;
	}
	public String getEmpId() {
		return empId;
	}
	public void setEmpId(String empId) {
		this.empId = empId;
	}
	public String getPassWord() {
		return passWord;
	}
	public void setPassWord(String passWord) {
		this.passWord = passWord;
	}
	public String getRealName() {
		return realName;
	}
	public void setRealName(String realName) {
		this.realName = realName;
	}
	public String getSex() {
		return sex;
	}
	public void setSex(String sex) {
		this.sex = sex;
	}
	public Date getBirthDate() {
		return birthDate;
	}
	public void setBirthDate(Date birthDate) {
		this.birthDate = birthDate;
	}
	public Date getHireDate() {
		return hireDate;
	}
	public void setHireDate(Date hireDate) {
		this.hireDate = hireDate;
	}
	public Date getLeaveDate() {
		return leaveDate;
	}
	public void setLeaveDate(Date leaveDate) {
		this.leaveDate = leaveDate;
	}
	public int getOnduty() {
		return onduty;
	}
	public void setOnduty(int onduty) {
		this.onduty = onduty;
	}
	public int getEmptype() {
		return emptype;
	}
	public void setEmptype(int emptype) {
		this.emptype = emptype;
	}
	public String getPhone() {
		return phone;
	}
	public void setPhone(String phone) {
		this.phone = phone;
	}
	public String getQq() {
		return qq;
	}
	public void setQq(String qq) {
		this.qq = qq;
	}
	public String getEmerContactPerson() {
		return emerContactPerson;
	}
	public void setEmerContactPerson(String emerContactPerson) {
		this.emerContactPerson = emerContactPerson;
	}
	public String getIdCard() {
		return idCard;
	}
	public void setIdCard(String idCard) {
		this.idCard = idCard;
	}
	public Department getDept() {
		return dept;
	}
	public void setDept(Department dept) {
		this.dept = dept;
	}
	public Position getPos() {
		return pos;
	}
	public void setPos(Position pos) {
		this.pos = pos;
	}
	public Employee getMgr() {
		return mgr;
	}
	public void setMgr(Employee mgr) {
		this.mgr = mgr;
	}
	public List<Employee> getEmpList() {
		return empList;
	}
	public void setEmpList(List<Employee> empList) {
		this.empList = empList;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result
				+ ((birthDate == null) ? 0 : birthDate.hashCode());
		result = prime * result + ((dept == null) ? 0 : dept.hashCode());
		result = prime
				* result
				+ ((emerContactPerson == null) ? 0 : emerContactPerson
						.hashCode());
		result = prime * result + ((empId == null) ? 0 : empId.hashCode());
		result = prime * result + ((empList == null) ? 0 : empList.hashCode());
		result = prime * result + emptype;
		result = prime * result
				+ ((hireDate == null) ? 0 : hireDate.hashCode());
		result = prime * result + ((idCard == null) ? 0 : idCard.hashCode());
		result = prime * result
				+ ((leaveDate == null) ? 0 : leaveDate.hashCode());
		result = prime * result + ((mgr == null) ? 0 : mgr.hashCode());
		result = prime * result + onduty;
		result = prime * result
				+ ((passWord == null) ? 0 : passWord.hashCode());
		result = prime * result + ((phone == null) ? 0 : phone.hashCode());
		result = prime * result + ((pos == null) ? 0 : pos.hashCode());
		result = prime * result + ((qq == null) ? 0 : qq.hashCode());
		result = prime * result
				+ ((realName == null) ? 0 : realName.hashCode());
		result = prime * result + ((sex == null) ? 0 : sex.hashCode());
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		if (birthDate == null) {
			if (other.birthDate != null)
				return false;
		} else if (!birthDate.equals(other.birthDate))
			return false;
		if (dept == null) {
			if (other.dept != null)
				return false;
		} else if (!dept.equals(other.dept))
			return false;
		if (emerContactPerson == null) {
			if (other.emerContactPerson != null)
				return false;
		} else if (!emerContactPerson.equals(other.emerContactPerson))
			return false;
		if (empId == null) {
			if (other.empId != null)
				return false;
		} else if (!empId.equals(other.empId))
			return false;
		if (empList == null) {
			if (other.empList != null)
				return false;
		} else if (!empList.equals(other.empList))
			return false;
		if (emptype != other.emptype)
			return false;
		if (hireDate == null) {
			if (other.hireDate != null)
				return false;
		} else if (!hireDate.equals(other.hireDate))
			return false;
		if (idCard == null) {
			if (other.idCard != null)
				return false;
		} else if (!idCard.equals(other.idCard))
			return false;
		if (leaveDate == null) {
			if (other.leaveDate != null)
				return false;
		} else if (!leaveDate.equals(other.leaveDate))
			return false;
		if (mgr == null) {
			if (other.mgr != null)
				return false;
		} else if (!mgr.equals(other.mgr))
			return false;
		if (onduty != other.onduty)
			return false;
		if (passWord == null) {
			if (other.passWord != null)
				return false;
		} else if (!passWord.equals(other.passWord))
			return false;
		if (phone == null) {
			if (other.phone != null)
				return false;
		} else if (!phone.equals(other.phone))
			return false;
		if (pos == null) {
			if (other.pos != null)
				return false;
		} else if (!pos.equals(other.pos))
			return false;
		if (qq == null) {
			if (other.qq != null)
				return false;
		} else if (!qq.equals(other.qq))
			return false;
		if (realName == null) {
			if (other.realName != null)
				return false;
		} else if (!realName.equals(other.realName))
			return false;
		if (sex == null) {
			if (other.sex != null)
				return false;
		} else if (!sex.equals(other.sex))
			return false;
		return true;
	}
	@Override
	public String toString() {
		return "Employee [empId=" + empId + ", passWord=" + passWord
				+ ", realName=" + realName + ", sex=" + sex + ", birthDate="
				+ birthDate + ", hireDate=" + hireDate + ", leaveDate="
				+ leaveDate + ", onduty=" + onduty + ", emptype=" + emptype
				+ ", phone=" + phone + ", qq=" + qq + ", emerContactPerson="
				+ emerContactPerson + ", idCard=" + idCard + ", dept=" + dept
				+ ", pos=" + pos + ", mgr=" + mgr + ", empList=" + empList
				+ "]";
	}

}

```



## 3.5  日历插件

> 使用日历插件的步骤
>
> 导入日历插件的Js文件，对 input 输入框添加焦点事件，使用 WdatePicker()函数，
>
> 配置使用参数 Json 格式 {属性名：属性值}

1. 导入日历插件的 Js 文件

```html
<!-- 导入日历插件 -->
<script type="text/javascript" src="My97DatePicker/WdatePicker.js"></script>
```

2. 添加鼠标事件，使用日历插件

```html
<li>
<label>出生日期</label>
	<input name="" type="text" class="dfinput" 		       onfocus="WdatePicker({lang:'en',skin:'whyGreen'})"/>
  	<i>也可以根据身份证号自动获取</i></li>
<li>
```

3. 调整日历插件的配置,使用 json 格式

```html
WdatePicker({lang:'en',skin:'whyGreen'})
```



## 3.6 富文本编辑器

> 使用富文本编辑器 KindEditor

1. 导入富文本编辑器 JS 文件

```html
<!-- 导入富文本编辑器插件 -->
<script type="text/javascript" src="editor/kindeditor.js"></script>
```

2.  绑定 ID

```html
<li>
<label>紧急联系人信息</label>
<textarea name=""  id="ecp" cols="" rows="" class="textinput"></textarea>
</li>
```

3. 修改配置

```html
<script>
		// 注意：要选择 id 键，指明在哪里使用富文本编辑器
		KE.show({id:"ecp",width:"500px",height:"300px;",resizeType:1,skinType:"tinymce",
			items:[
		        'source', '|', 'undo', 'redo', '|', 'preview', 'print', 'template', 'code', 'cut', 'copy', 'paste',
		        'plainpaste', 'wordpaste', '|', 'justifyleft', 'justifycenter', 'justifyright',
		        'justifyfull', 'insertorderedlist', 'insertunorderedlist', 'indent', 'outdent', 'subscript',
		        'superscript', 'clearhtml', 'quickformat', 'selectall', '|', 'fullscreen', '/',
		        'formatblock', 'fontname', 'fontsize', '|', 'forecolor', 'hilitecolor', 'bold',
		        'italic', 'underline', 'strikethrough', 'lineheight', 'removeformat', '|', 'image', 'multiimage',
		        'flash', 'media', 'insertfile', 'table', 'hr', 'emoticons', 'baidumap', 'pagebreak',
		        'anchor', 'link', 'unlink', '|', 'about'
		]
		});
		
	</script>
```

## 3.8  一对多查询

> SQL 语句采用多表连接的方式，按需求将所需数据查找出来。
>
> 不建议采用 调用其他 dao 层 对象查找所需数据，再组合起来，这样耦合性高，查询效率不理想。

```java
@Override
	public List<Employee> findAllEmpsInfoService() {
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		List<Employee> emps = null;
		try {
			conn = DBUtil.getConnection();
			/*String sql = "select * from employee";*/
			String sql = "select  e.*,d.deptname,d.location,p.pname,mgr.empid,mgr.realname"+
						 "	from employee e"+
						 "	left join dept d"+
						 "	on e.deptno = d.deptno"+
						 "	left join position p"+
						 "	on e.posid = p.posid"+
						 "	left join employee mgr"+
						 "	on e.mgrid = mgr.empid";
			ps = conn.prepareStatement(sql);
			rs = ps.executeQuery();
			emps = new ArrayList<>();
			while(rs.next()){
				Employee emp = new Employee();
				emp.setEmpId(rs.getString("empid"));
				emp.setRealName(rs.getString("realname"));
				emp.setPassWord(rs.getString("password"));
				emp.setSex(rs.getString("sex"));
				emp.setHireDate(rs.getDate("hiredate"));
				emp.setBirthDate(rs.getDate("birthdate"));
				emp.setLeaveDate(rs.getDate("leavedate"));
				emp.setPhone(rs.getString("phone"));
				emp.setEmptype(rs.getInt("emptype"));
				emp.setOnduty(rs.getInt("onduty"));
				emp.setQq(rs.getString("qq"));
				emp.setEmerContactPerson(rs.getString("emercontactperson"));
				emp.setIdCard(rs.getString("idcard"));
				
				Department dept = new Department();
				dept.setDeptno(rs.getInt("deptno"));
				dept.setDeptName(rs.getString("deptName"));
				emp.setDept(dept);
				
				Position pos = new Position();
				pos.setPosid(rs.getInt("posid"));
				pos.setPosName(rs.getString("pname"));
				emp.setPos(pos);
				
				Employee mgr = new Employee();
				mgr.setEmpId(rs.getString("empid"));
				mgr.setRealName(rs.getString("realname"));
				emp.setMgr(mgr);
				
				// 耦合性太高，而且查询速度慢
			/*	//调用 DepartmentDao
				DepartmentDao deptDao = new DepartmentDaoImpl();
				Department dept = deptDao.findDeptInfoByIdDao(rs.getInt("emptype")); 
				emp.setDept(dept);
				//调用 PositionDao 
				PositionDao posDao = new PositionDaoImpl();
				Position pos = posDao.findPosInfoById(rs.getString("posid"));
				emp.setPos(pos);
				//调用 this ,查找该员工的上级信息
				Employee mgr = this.findEmpInfoByIdDao(rs.getString("mgrid"));
				emp.setMgr(mgr);
				//调用 this ，查找该员工的所有下级信息
				List<Employee> empList = this.findEmpsInfoByMgrDao(rs.getString("mgrid"));
				emp.setEmpList(empList);*/
						
				emps.add(emp);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			DBUtil.closeAll(rs, ps, conn);
		}
		return emps; 
	}

```

## 3.9  动态 SQL语句

> 使用 `StringBuilder` 类中 `append` 方法，j加上 if  条件动态控制 where 子句的查询条件的选择

```java
/*String sql = "select * from employee";*/
StringBuilder sql = new StringBuilder("select  e.*,d.deptname,d.location,p.pname,mgr.empid,mgr.realname mgrRealName"+
				" from employee e"+
				" left join dept d"+
				" on e.deptno = d.deptno"+
				" left join position p"+
				" on e.posid = p.posid"+
				" left join employee mgr"+
				" on e.mgrid = mgr.empid where 1=1");
				
				if(empId !=null&&!empId.equals("")){
					sql.append(" and e.empid like '%"+empId+"%'");
				}
				
				if(deptNO !=null && !deptNO.equals("0")){
					sql.append(" and e.deptno ="+deptNO);
				}
				
				if(onDuty !=null && !empId.equals("")){
					sql.append(" and e.onDuty ="+onDuty);
				}
				
				
				System.out.println(sql.toString());
				ps = conn.prepareStatement(sql.toString());
```

## 3.10 servlet 接受表单数据预处理

> 通过预先对传入的数据进行 null 值判断。

```java
// 转换日期格式
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-mm-dd");
Date birthDate = null;
try {
    birthDate = sdf.parse(sBirthDay);
} catch (ParseException e) {
    e.printStackTrace();
}

if(hireDate !=null && !hireDate.equals("")){
    Date date = new java.sql.Date(hireDate.getTime());
    sql.append(" and to_char(e.hiredate,'yyyy-MM-dd') >='"+date+"'");
}
```

## 3.11 获取同名列的问题

> 解决方法：为同名列起别名，区分不同同名列。

```java
StringBuilder sql = 
 	new StringBuilder("select  e.*,d.deptname,d.location,p.pname,mgr.empid,mgr.realname mgrRealName"+
                      " from employee e"+
                      " left join dept d"+
                      " on e.deptno = d.deptno"+
                      " left join position p"+
                      " on e.posid = p.posid"+
                      " left join employee mgr"+
                      " on e.mgrid = mgr.empid where 1=1");
				
```

## 3.12 form表单提交问题

> 注意：写明提交方式，否则 action 后面附带的参数不提交。

## 3.13 删除员工

> 不删除员工，将员工设为离职状态

## 3.14 更新员工信息

> 设置员工的用户名不可修改
>
> 寻找插件将输入的用户名中文转为收汉语拼音



# 4 考勤模块

## 4.1 登录模块

```html
<input name="pwd" type="password" class="loginpwd" value="" onclick="JavaScript:this.value=''"/>  <!-- 单击清空输入框  ->
```



### 4.1.1 菜单分栏

> 根据用户的类型，显示不同的菜单。

### 4.1.2 验证码

> 登录验证码

```java
package com.szxy.web.servlet;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;



public class RandomServlet extends HttpServlet {

	
	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		// 在内存中创建图象
		int width = 110, height = 30;
		BufferedImage image = new BufferedImage(width, height,
				BufferedImage.TYPE_INT_RGB);
		// 获取图形上下文
		Graphics g = image.getGraphics();
		// 生成随机类
		Random random = new Random();
		// 设定背景色
		g.setColor(getRandColor(200, 250));
		g.fillRect(0, 0, width, height);
		// 设定字体
		g.setFont(new Font("Times New Roman", Font.PLAIN, 20));
		// 随机产生155条干扰线，使图象中的认证码不易被其它程序探测到
		g.setColor(getRandColor(160, 200));
		for (int i = 0; i < 155; i++) {
			int x = random.nextInt(width);
			int y = random.nextInt(height);
			int xl = random.nextInt(12);
			int yl = random.nextInt(12);
			g.drawLine(x, y, x + xl, y + yl);
		}
		// 取随机产生的认证码(6位数字)
		String sRand = "";
		for (int i = 0; i < 6; i++) {
			String rand = String.valueOf(random.nextInt(10));
			sRand += rand;
			// 将认证码显示到图象中
			g.setColor(new Color(20 + random.nextInt(110), 20 + random
					.nextInt(110), 20 + random.nextInt(110)));
			// 调用函数出来的颜色相同，可能是因为种子太接近，所以只能直接生成
			g.drawString(rand, 13 * i + 6, 16);
		}
		// 图象生效
		g.dispose();
		
		try {
			ImageIO.write(image, "JPEG", response.getOutputStream());
		} catch (Exception e) {
			System.out.println("验证码图片产生出现错误：" + e.toString());
		}
		//保存验证码到Session
		request.getSession().setAttribute("randStr", sRand);
	/*	System.out.println("randStr"+sRand);*/
		
	}


	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		this.doGet(request, response);
	}
	/*
	 * 给定范围获得随机颜色
	 */
	private Color getRandColor(int fc, int bc) {
		Random random = new Random();
		if (fc > 255)
			fc = 255;
		if (bc > 255)
			bc = 255;
		int r = fc + random.nextInt(bc - fc);
		int g = fc + random.nextInt(bc - fc);
		int b = fc + random.nextInt(bc - fc);
		return new Color(r, g, b);
	}
}

```



## 4.5 查看考勤信息模块

### 4.5.1  动态 SQL 

> 注意：拼接 字符串SQL 时，注意两边需要加单引号

```java
StringBuilder  sql = new StringBuilder("select dt.*,e.realname,d.deptno deptno,d.deptname"+
						" from duty  dt"+
						" join employee e"+
						" on dt.emprid = e.empid"+
						" join dept d"+
						" on e.deptno = d.deptno"+
						" where 1=1");
			
			if(empId!=null&&!"".equals(empId)){
				sql.append("and dt.emprid = '"+empId+"'");
			}
			if(deptNo!=0){
				sql.append("and d.deptno = "+deptNo);
			}
			if(dtDate!=null&!"".equals(dtDate)){
				sql.append("and to_char(dt.dtdate,'yyyy-MM-dd') >='"+dtDate+"'");
			
			}
			System.out.println(sql.toString());
```

### 4.5.2 PIO

> [Apache](https://baike.baidu.com/item/Apache/6265) POI 是用[Java](https://baike.baidu.com/item/Java/85979)编写的免费开源的跨平台的 Java API，Apache POI提供API给Java程式对[Microsoft Office](https://baike.baidu.com/item/Microsoft Office)格式档案读和写的功能。POI为“Poor Obfuscation Implementation”的首字母缩写，意为“简洁版的模糊实现”。

- 栗子

  将考勤信息导出为 xls 格式的文档，然后通过浏览器下载到本地保存

  注意：将xls格式的文档通过流的方式发送给客户端，并且要设置响应数据的格式和响应头

```java
// 根据条件查询考勤信息
	public void findAllDutyInfoByCondition(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException{
		//获取请求处理参数
		String empId = req.getParameter("empId");
		
		String sdeptNo = req.getParameter("deptNo");
		int deptNo = 0;
		try{
			deptNo = Integer.valueOf(sdeptNo); // null 、非法字符
		}catch(NumberFormatException e){
			e.printStackTrace();
		}
		
		String sdtDate = req.getParameter("dtDate");
		Date dtDate = null;
		try{
			DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
			dtDate = sdf.parse(sdtDate);
		}catch(Exception e){
			e.printStackTrace();
		}
		
		//调用业务层对象
		List<Duty> dutyList = dutyService.findAllDutyInfoByConditionService(empId,deptNo,dtDate);
		//响应处理结果
		Gson gson = new GsonBuilder().setDateFormat("yyyy-MM-dd").create();//日期格式化
		resp.getWriter().print(gson.toJson(dutyList));//使用 ajax ，直接响应
	}
	
	// 导出 考勤信息 xls 文档
	public void exportXls(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException{
		//获取请求处理参数
		String empId = req.getParameter("empId");
		
		String sdeptNo = req.getParameter("deptNo");
		int deptNo = 0;
		try{
			deptNo = Integer.valueOf(sdeptNo); // null 、非法字符
		}catch(NumberFormatException e){
			e.printStackTrace();
		}
		
		String sdtDate = req.getParameter("dtDate");
		Date dtDate = null;
		try{
			DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
			dtDate = sdf.parse(sdtDate);
		}catch(Exception e){
			e.printStackTrace();
		}
		
		//调用业务层对象
		List<Duty> dutyList = dutyService.findAllDutyInfoByConditionService(empId,deptNo,dtDate);
		
		//响应处理结果
		createExcel(dutyList,resp);
		
	}
  private static void createExcel(List<Duty> list,HttpServletResponse resp) {
        // 创建一个Excel文件
        HSSFWorkbook workbook = new HSSFWorkbook();
        // 创建一个工作表
        HSSFSheet sheet = workbook.createSheet("考勤表一");
        
        CellRangeAddress region = new CellRangeAddress(0, // first row
                0, // last row
                0, // first column
                2 // last column
        );
        sheet.addMergedRegion(region);
        
        HSSFRow hssfRow = sheet.createRow(0);
        HSSFCell headCell = hssfRow.createCell(0);
        headCell.setCellValue("OA系统之考勤列表");
        
        // 设置单元格格式居中
        HSSFCellStyle cellStyle = workbook.createCellStyle();
    	cellStyle.setAlignment(HSSFCellStyle.ALIGN_CENTER);
      
        headCell.setCellStyle(cellStyle);
        
        // 添加表头行
        hssfRow = sheet.createRow(1);
        // 添加表头内容
        headCell = hssfRow.createCell(0);
        headCell.setCellValue("用户名");
        headCell.setCellStyle(cellStyle);

        headCell = hssfRow.createCell(1);
        headCell.setCellValue("真实姓名");
        headCell.setCellStyle(cellStyle);

        headCell = hssfRow.createCell(2);
        headCell.setCellValue("所属部门");
        headCell.setCellStyle(cellStyle);
        
        headCell = hssfRow.createCell(3);
        headCell.setCellValue("出勤日期");
        headCell.setCellStyle(cellStyle);
        
        headCell = hssfRow.createCell(4);
        headCell.setCellValue("签到时间");
        headCell.setCellStyle(cellStyle);
        
        headCell = hssfRow.createCell(5);
        headCell.setCellValue("签退时间");
        headCell.setCellStyle(cellStyle);

        // 添加数据内容
        for (int i = 0; i < list.size(); i++) {
            hssfRow = sheet.createRow((int) i + 2);
            Duty duty = list.get(i);

            // 创建单元格，并设置值
            HSSFCell cell = hssfRow.createCell(0);
            cell.setCellValue(duty.getEmpId());
            cell.setCellStyle(cellStyle);

            cell = hssfRow.createCell(1);
            cell.setCellValue(duty.getEmp().getRealName());
            cell.setCellStyle(cellStyle);

            cell = hssfRow.createCell(2);
            cell.setCellValue(duty.getEmp().getDept().getDeptName());
            cell.setCellStyle(cellStyle);
            
            cell = hssfRow.createCell(3);
            cell.setCellValue(duty.getDtDate());
            cell.setCellStyle(cellStyle);
            
            cell = hssfRow.createCell(4);
            cell.setCellValue(duty.getSignInTime());
            cell.setCellStyle(cellStyle);
            
            cell = hssfRow.createCell(5);
            cell.setCellValue(duty.getSignOutTime());
            cell.setCellStyle(cellStyle);
        }

        // 保存Excel文件
        try {
           /* OutputStream outputStream = new FileOutputStream("D:/students.xls");*/ //保存到本地（即服务器）
        		//设置响应数据格式
        		resp.setContentType("application/vnd.ms-excel");
        		resp.setHeader("Content-disposition", "attachment; fileName=duty.xls");
        		OutputStream outputStream  = resp.getOutputStream();
	            workbook.write(outputStream);
	            outputStream.close();
	        } catch (Exception e) {
	            e.printStackTrace();
	        }
	    }
```

# 5 报销模块

注意： Oracle 不能获取 char 类型的字符 	



## 5.1 自定义异常

> 直接异常的结果抛给调用该类的上级处理



### 5.5.1 自定义异常类

```java
package com.szxy.util;

/**
 * 自定义异常信息

 */
public class MyException extends RuntimeException {
	
		public MyException() {
			super();
		}
		
	
		public MyException(String message) {
			super(message);
		}
	  
}	

```



### 5.1.2 DBUtil 使用自定义异常类

```java
public static int executeDML(String sql,Object...objs){
	
				Connection conn = null;
				PreparedStatement ps = null;
				int i = -1;
				try {
	
					conn = DBUtil.getConnection();

					conn.setAutoCommit(false);

					ps = conn.prepareStatement(sql);
					if(objs!=null){
						for(int j=0;j<objs.length;j++){
							ps.setObject(j+1,objs[j]);
						}
					}
				
					i = ps.executeUpdate();
					conn.commit();
				} catch (Exception e) {
					try {
						conn.rollback();
					} catch (SQLException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
					}
					e.printStackTrace();
					//抛出给上级调用者
					throw new MyException(e.toString());
				} finally {
					DBUtil.closeAll(null, ps, conn);
				}
				return i;
	}
```

## 5.2 servlet 中调用业务层发生错误的处理办法

> 使用 try{}catch{}语句,若调业务层发生错误，则直接打印错误信息，并把错误信息返回给客户端

```java
try{
				expenseService.add(exp); //不接受返回值	
				//响应处理结果
				resp.sendRedirect(req.getContextPath()+"/expense/myExpense.jsp");
			}catch(Exception e){
				e.printStackTrace();
				//业务层发生错误，则重定向到添加报销单界面，并携带错误信息
				req.setAttribute("error", "添加报销单失败");
				req.getRequestDispatcher("/expense/expenseAdd.jsp").forward(req, resp);
			}
```



## 5.3 service 层事务处理

> 在 dao 层，一个DML操作就相当于一个事务。
>
> 但是当 service 层，调用两个不同 dao 层，就相当于执行不同两个事务。
>
> 问题：将 两个 dao 层的事务，在 service 层合并成一个事务操作？
>
> 解决：
>
> 在 service 层，先关闭事务的自动提交，并在DML 操作成功执行完毕后 commit 提交，否则 rollback 。	
>
> ​	1. 在 service 创建 Connection 连接对象，将该对象传入 DML 操作中。 缺点：过于麻烦
>
> ​	2.修改 DBUtil 工具类，改用 TreadLocal 类获取 Connection 连接对象。
>
> 
>
> 注意：保证两个不同 dao 层的 DML 操作使用同一个 Connection 连接对象。 
>
> 

```java
package com.szxy.service.impl;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

import com.szxy.dao.ExpenseDao;
import com.szxy.dao.ExpenseItemDao;
import com.szxy.dao.impl.ExpenseDaoImpl;
import com.szxy.dao.impl.ExpenseItemDaoImpl;
import com.szxy.pojo.Expense;
import com.szxy.pojo.ExpenseItem;
import com.szxy.service.ExpenseService;
import com.szxy.util.DBUtil;
import com.szxy.util.DBUtil2;
import com.szxy.util.MyException;

/**
 * 	报销单类
 * 	
 * 问题：怎么获取当前报销单编号？ 
 * 解决：获取当前序列的值
 * 
 * 
 * 在 dao 层，一个DML操作就相当于一个事务。
 * 但是当 service 层，调用两个不同 dao 层，就相当于执行不同两个事务。
 * 问题：将 两个 dao 层的事务，在 service 层合并成一个事务操作？
 * 解决：
 * 		在 service 层，先关闭事务的自动提交，并在DML 操作成功执行完毕后 commit 提交，否则 rollback 。	
 * 		1. 在 service 创建 Connection 连接对象，将该对象传入 DML 操作中。 缺点：过于麻烦
 * 		2. 修改 DBUtil 工具类，改用 TreadLocal 类获取 Connection 连接对象。
 * 
 * 注意：保证两个不同 dao 层的 DML 操作使用同一个 Connection 连接对象。 
 * 	
 *  
 *
 */
public class ExpenseServiceImpl implements ExpenseService{
	ExpenseDao  expenseDao = new ExpenseDaoImpl();
	ExpenseItemDao itemDao = new ExpenseItemDaoImpl();
	//添加报销单信息s
	@Override
	public void add(Expense exp) {
		
		//获取当前序列的值
		int nextVal = expenseDao.getExpidNextval();
		
		//获取 数据库连接 对象
		Connection conn = DBUtil2.getConnection();
		//关闭事务自动提交
		try {
			conn.setAutoCommit(false);
			//保存报销单主表
			java.sql.Date exptime = new java.sql.Date(exp.getExptime().getTime());
			Expense expense = 
			new Expense(nextVal,exp.getEmpId(), exp.getTotalAmount(),exptime , exp.getExpdesc(), exp.getNextAuditor(), exp.getLastResult(), exp.getStatus());
			expenseDao.save(expense);
			
			//保存报销单明细
			List<ExpenseItem> itemList = exp.getItemList();
			for (int i = 0; i < itemList.size(); i++) {
				ExpenseItem item = 
				new ExpenseItem(nextVal,itemList.get(i).getType(), itemList.get(i).getAmount(), itemList.get(i).getItemdesc());
				itemDao.save(item);
			}
			//成功执行上面的 DML 操作后，提交事务
			conn.commit(); 
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			//抛出给上级调用者
			throw new MyException(e.toString());
		}finally{
			//关闭数据库连接
			DBUtil2.closeAll(null, null, conn);
		}
		
		
			
		
	}
	
}

```

## 5.4 使用浏览器地址栏上的信息

> 不通过 servlet 转发，采用 EL 表达式实现 

```html
<input  type="text" name="name" value=${param.地址栏上带有的参数名} "/>
<!-- 相当于 req.getParameter("参数名") -->
```



## 5.5 关闭子窗口，刷新父窗口

>  `window.close(); `//关闭当前窗口
> ` window.opener.location.reload();`    //刷新父窗口

```html
<script>
$.ajax({
    url:"expense",
    data:{method:"audit",expId:expId,result:result,auditDesc:auditDesc},
    type:"POST",
    success:function(data){
        if(data == "success"){
            alert("审核成功");
            window.close(); //关闭当前窗口
            window.opener.location.reload();    //刷新父窗口
             /* 	window.location.reload(); //刷新当前窗口 */
        }else{
            alert("审核失败");
        }
    }
});
  </script>
```





## 5.6  画业务流程图

![](http://www.zwer.xyz/picGo/审核流程图1.png)

### 5.6.1 第一步

```java
/**
	 *   审核报销单
	 */
	@Override
	public void audit(Auditing audit) {
		
		//根据业务流程图，写出大概步骤
		if(是财务){//是财务
			//添加财务支出信息
			//修改报销单状态
		}else{//不是财务
			if(审核通过){//审核通过
				
				if(>2500){
					if(总裁){ //是总裁
						//添加审核记录
						//修改报销单状态
					}else{
						//添加审核记录
						//修改报销单状态
					}
				}else{//小于 2500
					//添加审核记录
					//修改报销单状态
				}
			}else{//审核没通过
				//添加审核记录
				//修改报销单状态
			}
		}
	}
```

### 5.6.2 第二步

```java
@Override
public void audit(Auditing audit) {
		//获取当前数据库连接
		Connection conn = DBUtil2.getConnection();
		try{
			conn.setAutoCommit(false); //关闭自动提交
			//根据业务流程图，写出大概步骤
			String empId = audit.getEmpId();//审核人的ID 
			if(empId.equals(Constants.POSITION_CFO)){//是财务
				//添加财务支出信息
				//修改报销单状态
			}else{//不是财务
				String result = audit.getResult();
				if(result.equals("通过")){//审核通过
					Expense expense = expenseDao.findExpenseByExpId(audit.getExpId());
					double totalAmount = expense.getTotalAmount();
					if(totalAmount > 2500){
						if(empId.equals(Constants.POSITION_CEO)){ //是总裁
							//添加审核记录
							auditDao.save(audit);
							
							Expense exp = new Expense();
							exp.setExpId(audit.getExpId());
							exp.setNextAuditor(null);
							exp.setLastResult("审核通过");
							exp.setStatus(Constants.EXPENSE_STATUS_AUDITED); 						
							//修改报销单状态
							expenseDao.update(exp);
						}else{
							//添加审核记录
							auditDao.save(audit);
							
							Expense exp = new Expense();
							exp.setExpId(audit.getExpId());
							exp.setNextAuditor("gaoqi");   //交给下一个审核人，简化难度
							exp.setNextAuditor(audit.getExp().getNextAuditor());  
							exp.setLastResult(Constants.EXPENSE_STATUS_AUDITING);
							exp.setStatus("1");
							//修改报销单状态
							expenseDao.update(exp);
						}
					}else{//小于 2500
						//添加审核记录
						auditDao.save(audit);
						Expense exp = new Expense();
						exp.setExpId(audit.getExpId());
						exp.setNextAuditor(null);
						exp.setLastResult("审核通过");
						exp.setStatus(Constants.EXPENSE_STATUS_AUDITED); 						
						//修改报销单状态
						expenseDao.update(exp);
					}
				}else{//审核没通过 ，一种是打回，一种是拒绝
					
					//添加审核记录
					auditDao.save(audit);
					
					Expense exp = new Expense();
					exp.setExpId(audit.getExpId());
					exp.setNextAuditor(null);
					exp.setLastResult("未通过");
					if("打回".equals(audit.getResult())){
						exp.setStatus(Constants.EXPENSE_STATUS_BACK); 						
					}else{//拒绝
						exp.setStatus(Constants.EXPENSE_STATUS_REJECT); 						
					}
					//修改报销单状态
					expenseDao.update(exp);
				}
			}
			
			conn.commit(); //提交事务
		}catch(Exception e){
			//回滚
			try {
				conn.rollback();
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
			e.printStackTrace();
			throw new MyException(e.toString());
		}finally{
			DBUtil2.closeAll(null, null, conn);
		}

	}*/
```

### 5.6.3 第三步优化

> 使用常量类，及合并多余代码

```java
@Override
	public void audit(Auditing audit) {
		//添加审核记录
		auditDao.save(audit);
		//添加报销单信息
		Expense exp = new Expense();
		exp.setExpId(audit.getExpId());
		
		//获取当前数据库连接
		Connection conn = DBUtil2.getConnection();
		try{
			conn.setAutoCommit(false); //关闭自动提交
			//根据业务流程图，写出大概步骤
			String empId = audit.getEmpId();//审核人的ID 
			if(empId.equals(Constants.POSITION_CFO)){//是财务
				//添加财务支出信息
				//修改报销单状态
			}else{//不是财务
				String result = audit.getResult();
				if(result.equals("通过")){//审核通过
					Expense expense = expenseDao.findExpenseByExpId(audit.getExpId());
					double totalAmount = expense.getTotalAmount();
					if(totalAmount > 2500){
						if(empId.equals(Constants.POSITION_CEO)){ //是总裁
							//添加审核记录
							exp.setNextAuditor(null);
							exp.setLastResult("审核通过");
							exp.setStatus(Constants.EXPENSE_STATUS_AUDITED); 						
						}else{
							//添加审核记录
							exp.setNextAuditor("gaoqi");   //交给下一个审核人，简化难度
							/*exp.setNextAuditor(audit.getExp().getNextAuditor()); */ 
							exp.setLastResult(Constants.EXPENSE_STATUS_AUDITING);
							exp.setStatus("1");
						}
					}else{//小于 2500
						exp.setNextAuditor(null);
						exp.setLastResult("审核通过");
						exp.setStatus(Constants.EXPENSE_STATUS_AUDITED); 						
					}
				}else{//审核没通过 ，一种是打回，一种是拒绝
					exp.setNextAuditor(null);
					exp.setLastResult("未通过");
					if("打回".equals(audit.getResult())){
						exp.setStatus(Constants.EXPENSE_STATUS_BACK); 						
					}else{//拒绝
						exp.setStatus(Constants.EXPENSE_STATUS_REJECT); 						
					}
				}
			}
			expenseDao.update(exp); //修改报销单状态
			conn.commit();    //提交事务
		}catch(Exception e){
			//回滚
			try {
				conn.rollback();
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
			e.printStackTrace();
			throw new MyException(e.toString());
		}finally{
			DBUtil2.closeAll(null, null, conn);
		}

}
```

## 5.7 使用常量类

> 替代直接使用变量

```java
package com.szxy.util;

/**
 * 
 * 常量类
 *
 */
public class Constants {
	
	//审核状态
	public static final String EXPENSE_STATUS_AUDITING = "1";  // 审核中
	public static final String EXPENSE_STATUS_AUDITED = "2";   // 审核完成
	public static final String EXPENSE_STATUS_BACK = "3";      // 打回
	public static final String EXPENSE_STATUS_REJECT = "4";    // 拒绝
	public static final String EXPENSE_STATUS_CASHED = "5";    // 打款
	
	//部门特殊职位姓名
	public static final String POSITION_CEO = "gaoqi";    //总裁
	public static final String POSITION_CFO = "lifuying"; //首席账务官
	
	
}
```

## 5.8  bug之数据库连接关闭

> 问题描述：最开始是使用一个用户处理报销单操作，审核没有问题，但是换到下一个用户时再处理报销单操作，出现审核失败，原因是数据库连接被关闭，但是数据库连接对象并没有被销毁。
>
> 解决：
>
> 在DBUtil2中，获取数据库连接方法中判断 conn 对象是否关闭 isClose()，若关闭则重新创建新的数据连接对象。
>
> 问题推测：可能是切换用户时，出现了数据库连接关闭或者 使用 ThreadLocal 管理 conn 对象的原因。

```java
public static Connection getConnection() {
		Connection conn=null;
		// 从 ThreadLocal 中获取 Connection 数据库连接对象
		conn = threadLocal.get();
		
		try {
			if( conn == null || conn.isClosed()){  //第一次创建 Connection 数据库连接对象,并且判断当前数据库是否关闭，若关闭需要重新创建
				try {
					conn = DriverManager.getConnection(url, username, password);
					//将 conn 放入 ThreadLocal 中
					threadLocal.set(conn);
				} catch (SQLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		/*try {
			System.out.println("conn的状态："+conn.isClosed());
		} catch (SQLException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}*/
		return conn;
	}
```

# 6 收支管理



## 6.1  echart （Enterprise charts 商业产品图标库）入门

> ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的矢量图形库 [ZRender](https://github.com/ecomfe/zrender)，提供直观，交互丰富，可高度个性化定制的数据可视化图表。

### 6.1.1  特性

1. 丰富的可视化类型

   ECharts 提供了常规的[折线图](https://echarts.baidu.com/option.html#series-line)、[柱状图](https://echarts.baidu.com/option.html#series-line)、[散点图](https://echarts.baidu.com/option.html#series-scatter)、[饼图](https://echarts.baidu.com/option.html#series-pie)、[K线图](https://echarts.baidu.com/option.html#series-candlestick)，用于统计的[盒形图](https://echarts.baidu.com/option.html#series-boxplot)，用于地理数据可视化的[地图](https://echarts.baidu.com/option.html#series-map)、[热力图](https://echarts.baidu.com/option.html#series-heatmap)、[线图](https://echarts.baidu.com/option.html#series-lines)，用于关系数据可视化的[关系图](https://echarts.baidu.com/option.html#series-graph)、[treemap](https://echarts.baidu.com/option.html#series-treemap)、[旭日图](https://echarts.baidu.com/option.html#series-sunburst)，多维数据可视化的[平行坐标](https://echarts.baidu.com/option.html#series-parallel)，还有用于 BI 的[漏斗图](https://echarts.baidu.com/option.html#series-funnel)，[仪表盘](https://echarts.baidu.com/option.html#series-gauge)，并且支持图与图之间的混搭。

2. 多种数据格式无需转换直接使用

   ECharts 内置的 dataset 属性（4.0+）支持直接传入包括二维表，key-value 等多种格式的数据源，通过简单的设置 encode 属性就可以完成从数据到图形的映射，这种方式更符合可视化的直觉，省去了大部分场景下数据转换的步骤，而且多个组件能够共享一份数据而不用克隆

### 6.1.2 使用

- 导入 eCharts.js 文件

```html
	<!-- 导入 eCharts 文件 -->
	<script type="text/javascript" src="js/echarts.min.js"></script>
```

- 新建一个 div ，并设置图标的格式和数据

```html
<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <base href="<%=basePath%>"/>
    
    <title>eCharts 图标入门</title>
    
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
	<meta http-equiv="description" content="This is my page">
	<!--
	<link rel="stylesheet" type="text/css" href="styles.css">
	-->
	<!-- 导入 Jquery  -->
	<script type="text/javascript" src="js/jquery.js"></script>
	<!-- 导入 eCharts 文件 -->
	<script type="text/javascript" src="js/echarts.min.js"></script>
  </head>
  	
  <body>
   		  <!-- 为 ECharts 准备一个具备大小（宽高）的 DOM -->
    	<div id="main" style="width: 600px;height:400px;"></div>
    	
    	<script type="text/javascript">
	        // 基于准备好的dom，初始化echarts实例
	        var myChart = echarts.init(document.getElementById('main'));

	        // 指定图表的配置项和数据
	        var option = {
	            title: {
	                text: 'ECharts 入门示例'
	            },
	            tooltip: {},
	            legend: {
	                data:['销量']
	            },
	            xAxis: {
	                data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
	            },
	            yAxis: {},
	            series: [{
	                name: '销量',
	                type: 'bar',  //表示柱状图
	                data: [5, 20, 36, 10, 10, 20]
	            }]
	        };
	
	        // 使用刚指定的配置项和数据显示图表。
	        myChart.setOption(option);
	   	 </script>
  </body>
</html>

```

### 6.1.3 效果

![](http://www.zwer.xyz/picGo/20190428205130.png)



# 7 项目总结

## 7.1 项目核心知识点

1. ServletAPI 的使用
2. JSP 四个作用域
3. JSTL 标签库与 EL 表达式

## 7.2 分层功能分配

- 实体类、dao 层基本上与数据库表相对应
- 业务层、控制层、视图层更倾向于按照模块划分



# 8 分页功能

## 8.1 分页的意义

1. 数据量较大，一次加载所需的时间长
2. 数据量较大，浏览器页面不能全局显示，采用分页，数据更加清晰明了

## 8.2  PageBean 分页工具类

```java
package com.bjsxt.util;

import java.util.List;

/**
 * 分页的三个基本属性
 * 1.每页几条记录size  可以有默认值5
 * 2.当前页号  index    可以有默认值1
 * 3.记录总数totalCount：不可能有默认值，需要查询数据库获取真正的记录总数
 * 
 * 4.一共多少页 ：totalPageCount=totalCount/size+1
 * 		5  30  31 32 33 34 35  
 * 5.上一页    index-1  当前页1，上一页1
 * 6.下一页   index+1  当前页是最后一页  下一页：还是最后一页
 * 
 * 扩展
 * 分页Bean还可以放要查询的数据  protected List<T> list;
 * 分页Bean还可以放页码列表     [1]  2  3  4  5   private int[] numbers;
 * 
 * @author Administrator
 *
 * @param <T>
 */
public class PageBean<T> {
	private int size = 5;//每页显示记录  //
	private int index = 1;// 当前页号      
	private int totalCount = 0;// 记录总数      ok
	
	private int totalPageCount = 1;// 总页数   ok
	
	
	
	private int[] numbers;//展示页数集合  //ok
	protected List<T> list;//要显示到页面的数据集  

	/**
	 * 得到开始记录
	 * @return
	 */
	public int getStartRow() {

		return (index - 1) * size;
	}

	/**
	 * 得到结束记录
	 * @return
	 */
	public int getEndRow() {
		
		return index * size;
	}

	/**
	 * @return Returns the size.
	 */
	public int getSize() {		
		return size;
	}

	/**
	 * @param size
	 * The size to set.
	 */
	public void setSize(int size) {
		if (size > 0) {
			this.size = size;
		}
	}
	/**
	 * @return Returns the currentPageNo.
	 */
	public int getIndex() {
		if (totalPageCount == 0) {
			
			return 0;
		}
		
		return index;
	}

	/**
	 * @param currentPageNo
	 * The currentPageNo to set.
	 */
	public void setIndex(int index) {
		if (index > 0) {
			this.index = index;
		}
	}

	/**
	 * @return Returns the totalCount.
	 */
	public int getTotalCount() {
		return totalCount;
	}

	/**
	 * @param totalCount
	 *  The totalCount to set.
	 */
	public void setTotalCount(int totalCount) {
		if (totalCount >= 0) {
			this.totalCount = totalCount;
			setTotalPageCountByRs();//根据总记录数计算总页�?
		}
	}

	
	public int getTotalPageCount() {
		return this.totalPageCount;
	}

	/**
	 * 根据总记录数计算总页�?
	 * 5   
	 * 20    4
	 * 23    5
	 */
	private void setTotalPageCountByRs() {
		if (this.size > 0 && this.totalCount > 0 && this.totalCount % this.size == 0) {
			this.totalPageCount = this.totalCount / this.size;
		} else if (this.size > 0 && this.totalCount > 0 && this.totalCount % this.size > 0) {
			this.totalPageCount = (this.totalCount / this.size) + 1;
		} else {
			this.totalPageCount = 0;
		}
		setNumbers(totalPageCount);//获取展示页数集合
	}

	public int[] getNumbers() {
		return numbers;
	}
	
	/**
	 * 设置显示页数集合
	 * 
	 * 默认显示10个页码
	 * 41  42  43  44    [45 ]   46  47  48  49  50
	 * 
	 * 
	 *  [1] 2  3 4  5 6 7 8  9  10
	 *  
	 *  41  42  43  44    45    46  47  [48]  49  50
	 * @param totalPageCount
	 */
	public void setNumbers(int totalPageCount) {
		if(totalPageCount>0){
			//!.当前数组的长度
			int[] numbers = new int[totalPageCount>10?10:totalPageCount];//页面要显示的页数集合
			int k =0;
			//
			//1.数组长度<10   1 2 3 4 ....   7
			//2.数组长度>=10
			//     当前页<=6  1 2 3 4    10
			//     当前页>=总页数-5           ......12 13 14 15  
			//     其他                                5  6  7 8   9 当前页(10)  10  11 12  13
			for(int i = 0;i < totalPageCount;i++){
				//保证当前页为集合的中�?
				if((i>=index- (numbers.length/2+1) || i >= totalPageCount-numbers.length) && k<numbers.length){
					numbers[k] = i+1;
					k++;
				}else if(k>=numbers.length){
					break;
				}				
			}
			
			this.numbers = numbers;
		}
		
	}
	
	public void setNumbers(int[] numbers) {
		this.numbers = numbers;
	}

	public List<T> getList() {
		return list;
	}

	public void setList(List<T> list) {
		this.list = list;
	}


/*
	public static int getTotalPageCount(int iTotalRecordCount, int iPageSize) {
		if (iPageSize == 0) {
			return 0;
		} else {
			return (iTotalRecordCount % iPageSize) == 0 ? (iTotalRecordCount / iPageSize) : (iTotalRecordCount / iPageSize) + 1;
		}
	}*/
}

```



### 8.3 数据库分页

### 8.3.1 Oracle 分页

> 需要用到三层子查询，注意 rownum 不能使用 大于，否则查询不到记录。

```sql
select *from(
  select rownum rn,t.* from(
  select * from student  order by score desc )t  
  where rownum <= 10 -- end 结束位置
  )stu 
  where rn > 5  -- 开始位置
```

### 8.3.2 MySql 分页

> 较为简单，只需使用 limit 子句

```sql
-- select * from tbl_book limit a,b ; 
-- 第一参数 a(a>=0) 表示从那条记录开始，第二个参数表示从索引 a(a>=0)  开始以后的 b(b>1) 条记录

select * from tbl_book limit 0,5; 
select * from tbl_book limit 5,5;  
select * from tbl_book limit 10,5;
```



## 8.4  通过函数提交表单

1. 使用 Js 方式提交表单数据

```javascript
<sciprt>
//修改每页显示的记录数  可行
		function changeSizeAndIndex2(size,index){
			//获取第一个表单的 action 属性
			document.forms[0].action = "servlet/SizeServlet?size="+size+"&index="+index;
			
			document.forms[0].submit(); //提交表单
		}
		//修改每页显示的记录数 可行
		function changeSizeAndIndex(size,index){
			//赋值 当前表单项的 name 属性键的值
			document.forms[0].size.value = size;
			document.forms[0].index.value = index;
			//获取表单
			document.forms[0].submit(); //提交表单
		}
</sciprt>	
```



2. 栗子

```html
<%@ page language="java" import="java.util.*" pageEncoding="utf-8"%>
<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>

<%
String path = request.getContextPath();
String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/";
%>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <base href="<%=basePath%>">
    
    <title>查询并显示所有学生信息</title>
    
	<meta http-equiv="pragma" content="no-cache">
	<meta http-equiv="cache-control" content="no-cache">
	<meta http-equiv="expires" content="0">    
	<meta http-equiv="keywords" content="keyword1,keyword2,keyword3">
	<meta http-equiv="description" content="This is my page">
	<script type="text/javascript" src="js/jquery.js"></script>
	
	<!--
	<link rel="stylesheet" type="text/css" href="styles.css">
	-->
	<script type="text/javascript">
		//跳转到指定页码
		function chageIndex(index){
			/* window.location.href="servlet/ShowAllServlet?index="+index; */
			window.location.href="servlet/SizeServlet?size="+size+"&index="+index;
		}
		//修改每页显示的记录数   有问题
		function changeSizeAndIndex3(size,index){
			var name = $("input[name=name]").val();
			var score = $("input[name=score]").val();
			//window.location.href="servlet/SizeServlet?size="+size+"&index="+index+"&name="+name+"&score="+score;
		}
		//修改每页显示的记录数  可行
		function changeSizeAndIndex2(size,index){
			//获取第一个表单的 action 属性
			document.forms[0].action = "servlet/SizeServlet?size="+size+"&index="+index;
			
			document.forms[0].submit(); //提交表单
		}
		//修改每页显示的记录数 可行
		function changeSizeAndIndex(size,index){
			//赋值 当前表单项的 name 属性键的值
			document.forms[0].size.value = size;
			document.forms[0].index.value = index;
			//获取表单
			document.forms[0].submit(); //提交表单
		}
	</script>
  </head>
  
  <body> 
  	<h1 align="center" style="font-size:20px;font-weight: 400;margin-bottom:50px;">查询和分页</h1>
  	<form action="servlet/SizeServlet" method="post" align="center">
  		<input type="hidden" name="size" value="${pageBean.size}">
  	    <input type="hidden" name="index" value="1"/>
	  	姓名<input name="name" type="text" value="${student.name}"/>&nbsp;&nbsp;
	  	<c:if test="${student.score == 0.0}">
		  	成绩>=<input type="text" name="score" value="" />
	  	</c:if>
	  	<c:if test="${student.score != 0.0 }">
		  	成绩>=<input type="text" name="score" value="${student.score}" />
	  	</c:if>
  	    <input type="submit" value="查询">
  	</form>
  	<hr/>
    <!-- 显示所有学生   /stumanager/    -->
    <table align="center" border="1" width="60%">
    	<tr>
    		<th>学生 编号</th>
    		<th>学生姓名</th>
    		<th>学生年龄</th>
    		<th>学生成绩</th>
    		<th>vs.index</th>
    		<th>更新操作</th>
    		<th>删除操作</th>
    	</tr>
    	<c:forEach items="${pageBean.list}" var="stu" varStatus="vs">
    		<tr>
    			<td>${stu.id }</td>
    			<td>${stu.name }</td>
    			<td>${stu.age }</td>
    			<td>${stu.score }</td>
    			<td>${vs.index }</td>
    			<td><a href="/stumanager/servlet/StudentServlet?operate=preupdate&sid=${stu.id}">更新</a></td>
    			<td><a href="/stumanager/servlet/StudentServlet?operate=delete&sid=${stu.id}">删除</a></td>
    		</tr>
    	</c:forEach>
    	<tr>
    		<td colspan="6" align="center">
    			<a href="javascript:changeSizeAndIndex(${pageBean.size},1)">首页</a>
    			<c:if test="${pageBean.index-1 >= 1}">
	    			<a href="javascript:changeSizeAndIndex(${pageBean.size},${pageBean.index-1})">上一页</a> 
    			</c:if>
    			<c:if test="${pageBean.index-1 < 1}">
	    				上一页
    			</c:if>
    			<c:forEach items="${pageBean.numbers}" var="nums">
    				<c:if test="${nums == pageBean.index }">
	    				[<a href="javascript:changeSizeAndIndex(${pageBean.size},${nums})">${nums}</a>]
    				</c:if>
    				<c:if test="${nums != pageBean.index }">
	    				<a href="javascript:changeSizeAndIndex(${pageBean.size},${nums})">${nums}</a>
    				</c:if>
    			</c:forEach>
    				<c:if test="${pageBean.index+1 <=pageBean.totalPageCount}">
	    			<a href="javascript:changeSizeAndIndex(${pageBean.size},${pageBean.index+1})">下一页</a>   
    			</c:if>  			
    			<c:if test="${pageBean.index+1 > pageBean.totalPageCount}">
	    				下一页							
    			</c:if>  
    			<a href="javascript:changeSizeAndIndex(${pageBean.size},${pageBean.totalPageCount})">尾页</a>
    			每页显示多少条记录数  
    			<%-- 明天开始任务 --%>
   				<select name="" onchange="changeSizeAndIndex(this.value,${pageBean.index})">
    			<c:forEach begin="5" end="25" step="5" var="i">
    					<c:if test="${pageBean.size == i}">
	    					<option value="${i}" selected="selected">${i}</option>
    					</c:if>
    					<c:if test="${pageBean.size != i}">
	    					<option value="${i}">${i}</option>
    					</c:if>
    			</c:forEach>
   				</select>
    			<!-- 跳转到第几页  -->
    			跳转到
    			<select name="" onchange="changeSizeAndIndex(${pageBean.size},this.value)" >
	    			<c:forEach items="${pageBean.numbers}" var="num">
	    				<c:if test="${num == pageBean.index}">
	    					<option value="${num}" selected="selected">${num }</option>	    					
	    				</c:if>
	    				<c:if test="${num != pageBean.index}">
	    					<option value="${num}">${num }</option>	    					
	    				</c:if>
    				</c:forEach>
    			</select>
    			
    	
    			共有${pageBean.totalCount} 条记录
    		</td>
    	</tr>
    
    </table>
   
  </body>
</html>

```



# 9 文件上传与下载

## 9.1 导入 jar 包

commons-fileupload.jar 依赖于下面的 commons-io.jar 。
commons-io.jar

## 9.2 文件上传

### 9.2.1 获取动态上下文地址

> 用于获取服务端存储文件的位置

```java
//File dir = new File("D:\\upload\\"); //这里指服务器的目录下
//File dir = new File("D:\\Program Files\\apache-tomcat-7.0.69-windows-x64\\apache-tomcat-7.0.69\\webapps\\updownload1\\WEB-INF\\upload"); //这里指服务器的目录下
//完善2：动态获取上下文路径
File dir = new File(this.getServletContext().getRealPath("upload"));
```

### 9.2.2 上传文件的中文乱码问题

```java
request.setCharacterEncoding("utf-8");

ServletFileUpload fileUpload = new ServletFileUpload(factory);
fileUpload.setHeaderEncoding("utf-8");  //设置上传文件的名字编码格式

//name 
if("name".equals(fileItem.getFieldName())){
    name = fileItem.getString("utf-8"); //按 utf-8 格式编码
}
```



### 9.2.3  限制文件上传的类型

```java
	//完善4：限制上传文件的类型
if(!"image/png".equals(photoType)){
    request.setAttribute("mess", "文件的类型不正确，应为 png 格式的图片");
    request.getRequestDispatcher("/add.jsp").forward(request,response);
    return;
}
```



### 9.2.4 限制文件上传的大小

```java
try {
    //完善3：限制上传文件的大小
    //设置单个上传文件的大小
    fileUpload.setFileSizeMax(200*1024); //限制的单个文件的大小为 200KB
    //设置上传文件的总大小
    fileUpload.setSizeMax(5*200*1024); //限制上传文件的总大小为 1000KB
    //将表单数据封装到 FileItem 对象中
    itemList = fileUpload.parseRequest(request);
} catch (FileUploadException e) {
    e.printStackTrace();
    //若超出文件大小，则 itemList 为 null,直接返回客户端错误信息
    request.setAttribute("mess", "单个文件大小超过限制 200KB");
    request.getRequestDispatcher("/add.jsp").forward(request,response);
    return;
}
```



### 9.2.5 使用UUID 

> 用于图片名称，防止图片名重复。

```java
UUID uuid = UUID.randomUUID(); //获取32位的16进制的数
String ufileName = uuid.toString(); //图片 uuid 名
String extName = 
realName.substring(realName.lastIndexOf(".")+1).toLowerCase();//图片格式扩展名
photoName = ufileName+"."+extName;
```

### 9.2.6 栗子

> 1. 创建 FileItemFactory 工厂
> 2. 创建  ServletFileUpload 上传类
> 3. 解析 request 对象，获取 FileItem集合 
> 4. 遍历 FileItem 集合，获取表单数据和非表单数据

```java
package com.bjsxt.servlet;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.UUID;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.fileupload.FileItem;
import org.apache.commons.fileupload.FileItemFactory;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.disk.DiskFileItemFactory;
import org.apache.commons.fileupload.servlet.ServletFileUpload;

import com.bjsxt.entity.Student;
import com.bjsxt.service.StudentService;
import com.bjsxt.service.impl.StudentServiceImpl;

public class AddServlet extends HttpServlet {


    public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        this.doPost(request, response);

    }


    public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {
        request.setCharacterEncoding("utf-8");
        //创建 FileItemFactory 工厂
        FileItemFactory factory = new DiskFileItemFactory();

        //创建  ServletFileUpload 上传类
        ServletFileUpload fileUpload = new ServletFileUpload(factory);
        fileUpload.setHeaderEncoding("utf-8");  //设置上传文件的名字编码格式

        //解析 request 对象，获取 FileItem集合 
        List<FileItem> itemList  = null;
        try {
            //完善3：限制上传文件的大小
            //设置单个上传文件的大小
            fileUpload.setFileSizeMax(200*1024); //限制的单个文件的大小为 200KB
            //设置上传文件的总大小
            fileUpload.setSizeMax(5*200*1024); //限制上传文件的总大小为 1000KB
            //将表单数据封装到 FileItem 对象中
            itemList = fileUpload.parseRequest(request);
        } catch (FileUploadException e) {
            e.printStackTrace();
            //若超出文件大小，则 itemList 为 null,直接返回客户端错误信息
            request.setAttribute("mess", "单个文件大小超过限制 200KB");
            request.getRequestDispatcher("/add.jsp").forward(request,response);
            return;
        }

        String name = null;
        int age =  0;
        Double score = 0.0;
        String realName = null;  //图片真实名称
        String photoName = null; //图片名称
        String photoType = null; //图片格式类型
        //遍历 FileItem 集合
        for (int i = 0; i < itemList.size(); i++) {
            FileItem fileItem = itemList.get(i);

            if(fileItem.isFormField()){ //是非 file 表单项
                //name 
                if("name".equals(fileItem.getFieldName())){
                    name = fileItem.getString("utf-8"); //按 utf-8 格式编码
                }
                //age
                if("age".equals(fileItem.getFieldName())){
                    age = Integer.valueOf(fileItem.getString());
                }
                //score
                if("score".equals(fileItem.getFieldName())){
                    String sScore = fileItem.getString();
                    score = Double.valueOf(sScore);
                }
            }else{// 是 file 表单项
                if("photo".equals(fileItem.getFieldName())){
                    realName = fileItem.getName();  //获取上传图片名称
                    photoType = fileItem.getContentType(); //获取上传图片的类型
                    //String is = fileItem.getString(); //获取上传图片的资源
                    //System.out.println(photoName+"\t"+photoType+"\t");

                    //完善4：限制上传文件的类型
                    if(!"image/png".equals(photoType)){
                        request.setAttribute("mess", "文件的类型不正确，应为 png 格式的图片");
                        request.getRequestDispatcher("/add.jsp").forward(request,response);
                        return;
                    }

                    //File dir = new File("D:\\upload\\"); //这里指服务器的目录下
                    //File dir = new File("D:\\Program Files\\apache-tomcat-7.0.69-windows-x64\\apache-tomcat-7.0.69\\webapps\\updownload1\\WEB-INF\\upload"); //这里指服务器的目录下
                    //完善2：动态获取上下文路径
                    File dir = new File(this.getServletContext().getRealPath("upload"));
                    //完善1：若文件夹不存在则创建该文件夹
                    if(!dir.exists()){
                        dir.mkdirs();
                    }
                    //完善5：使用UUID 作为图片名
                    UUID uuid = UUID.randomUUID(); //获取32位的16进制的数
                    String ufileName = uuid.toString(); //图片 uuid 名
                    String extName = realName.substring(realName.lastIndexOf(".")+1).toLowerCase();//图片格式扩展名
                    photoName = ufileName+"."+extName;
                    //System.out.println("图片格式扩展名："+extName);

                    File  file = new File(dir,photoName);

                    //上传到指定的目录下
                    try {
                        fileItem.write(file);
                    } catch (Exception e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            }
        }
        //System.out.println(name+"\t"+age+"\t"+score);

        StudentService service = new StudentServiceImpl();
        Student stu = new Student(name, age, score, realName, photoName, photoType);
        int n = service.save(stu) ; //保存学生信息
        //页面跳转
        if(n!=0){
            //重定向:/后面要跟上下文路径  /stumgr   /stumgr2

            response.sendRedirect(request.getContextPath()+"/servlet/ShowAllServlet");
        }else{
            request.setAttribute("mess", "添加失败!");
            request.getRequestDispatcher("/add.jsp").forward(request, response);
        }

    }

}



```





## 9.3 文件下载

> 使用IO流的方式将服务器的文件资源发送给客户端
>
> 中间使用 IOUtils 工具类（org.apache.commons.io.IOUtils）。
>
> 注意：流使用后要关闭。
>
> ​		  添加响应头说明该文件是的大小、类型及文件名

### 9.3.1 下载中文名乱码问题

```java
String realName = stu.getRealName();
/*byte[] bytes = realName.getBytes("utf-8");
			String realName2 = new String(bytes,"utf-8");*/ 
String realName2 = null;
String userAgent = req.getHeader("User-Agent").toLowerCase();
if(userAgent.indexOf("trident") >= 0){//如果是 IE 浏览器
    realName2 = URLEncoder.encode(realName,"utf-8");
}else{
    realName2 = new String(realName.getBytes("utf-8"),"iso-8859-1"); //服务器发送给客户端，Get 编码方式反过来
}
resp.setHeader("Content-Disposition", "attachment;filename="+realName2);
OutputStream out = resp.getOutputStream();
```

### 9.3.2 栗子

```java
package com.bjsxt.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URLEncoder;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.IOUtils;

import com.bjsxt.entity.Student;
import com.bjsxt.service.StudentService;
import com.bjsxt.service.impl.StudentServiceImpl;

public class DownloadServlet extends HttpServlet {

	@Override
	protected void service(HttpServletRequest req, HttpServletResponse resp)
			throws ServletException, IOException {
			//1. 接受请求数据，学生的ID
			String sId = req.getParameter("id");
			int id = -1;
			try {
				id = Integer.valueOf(sId);
			} catch (Exception e) {
				e.printStackTrace();
			}
			//2. 处理请求数据
			StudentService service = new StudentServiceImpl();
			Student stu = service.findById(id);
			//3. 响应请求数据      使用IO流的方式
			//3.1  获取输入输出流
			String realPath = this.getServletContext().getRealPath("upload");
			File file = new File(realPath+"/"+stu.getPhotoName());
			InputStream is  = new FileInputStream(file);
			// 添加响应头信息
			resp.setContentLength((int)file.length()); //设置响应内容的长度
			resp.setContentType(stu.getPhotoType()); //设置响应内容的格式
			//处理图片真实名称中文乱码问题
			String realName = stu.getRealName();
			/*byte[] bytes = realName.getBytes("utf-8");
			String realName2 = new String(bytes,"utf-8");*/ 
			String realName2 = null;
			String userAgent = req.getHeader("User-Agent").toLowerCase();
			if(userAgent.indexOf("trident") >= 0){//如果是 IE 浏览器
				realName2 = URLEncoder.encode(realName,"utf-8");
			}else{
				realName2 = new String(realName.getBytes("utf-8"),"iso-8859-1"); //服务器发送给客户端，Get 编码方式反过来
			}
			resp.setHeader("Content-Disposition", "attachment;filename="+realName2);
			OutputStream out = resp.getOutputStream();
			//3.2 将输入流复制到输出流中
			IOUtils.copy(is, out);
			//3.3 关闭流
			is.close();
			out.close();
			
	}

}

```



# 10 版本管理与SVN 入门

## 10.1 版本管理的概念

> 解决：代码合并、历史版本中的迭代、重复

### 10.1.2  版本控制软件

a) VSS：Microsoft 提供，Window 平台，小型开发团队所适合的工具。

b) CVS：开源工具，跨平台。绝大多数 CVS 服务已改用 SVN。CVS 已停止维护

c) SVN（Subversion）：开源，跨平台，在 CVS 的基础上开发。使用企业众多， 稳定安全，操作简单。集中式版本控制系统。

d) GIT：开源的分布式版本控制系统，用以有效高速的处理从很小到非常大的项

目版本管理。（GITHUB 是一个用 GIT 做版本控制的项目托管平台，B/S 架构。放到 GITHUB 上的代码需要开源，并且是互联网开发）

![](http://www.zwer.xyz/picGo/20190506083256.png)



## 10.2 SVN入门

### 10.2.1 安装软件

a) 指定软件安装位置和版本库位置

b) 默认端口 443

c) 使用 SVN authentication

### 10.2.2  创建版本库

a) 创建默认结构 use default struction

b) 默认结构的含义

i. trunk：主干	开发时代码存储的位置，永远是最新的代码

ii. brank：分支	在不影响Trunk 其它用户情况下进行一些关于新功能的探索性或实验性的开发，待新功能完善后它也可以合并到 Trunk 中

iii. tags：标签 历史版本 阶段性里程碑版本 比如 1.0 2.0 3.0

### 10.2.3 创建用户

### 10.2.4 创建组

### 1 0.2.5 为组指定用户

### 10.2.6  为组指定对版本库的操作权限

​	a) 默认 everyone 具有 read/write 权限，无法删除，要修改为 no access

###  10.2.7  通过浏览器访问服务器端

### 10.3 客户端 subclipse 

> 一款 eclipse 中的 SNV 客户端插件。

### 10.3.1 安装

a) 解压后将其中的 features 和 plugin 文件夹放入MyEclipse 的 dropins 目录下

b) 重新启动MyEclipse，即可自动发现并安装

c) 安装后在 window------preferrences---—team 中可以看到 SVN

### 10.3.2  提交项目到服务器端

a) 选中项目右键--------team----share project	选择 SVN

b) 提交版本位置、用户名、密码都会由相关服务器管理人员提供。

![](http://www.zwer.xyz/picGo/20190506083833.png)

a) 可以选择记住密码，避免多次的重复输入。

b) 提交后会跳到 team synchronizing view，还需要真正同步代码到服务器，同步之前可以选择哪些代码不需要使用 svn 进行管理

c) 提交成功后可以观察版本库容量的变化

d) 提交成功后客户端项目会显示专门的标记，并且增加了相应的.svn 项目，来存储操作记录

![](http://www.zwer.xyz/picGo/20190506083935.png)

![](http://www.zwer.xyz/picGo/20190506083951.png)

### 10.3.4 断开和服务器连接

a) team—断开连接	从项目中删除 SVN 元信息

### 10.3.5 客户端从 SVN 检出项目

a) new--- Project…--------SVN	从 SVN 检出项目

### 10.3.6 更新和提交操作

a) 更新将服务器最新代码更新到本地；提交是将本地最新代码提交到服务器

b) **提交之前要先更新**，因为可能其他程序员期间以及提交了最新代码到服务器

c) **提交一定要给出注释**，对提交内容进行说明，作为以后辨别版本的主要依据。

### 10.3.7 解决冲突

a) 模拟两个用户对一个类进行修改，分别修改相同的方法和增加一个新方法

b) 更新后出现冲突，和冲突方沟通后，对冲突文件给出最终解决方案

c) 还需要 team	标记为解决，相应冲突文件为自动删除，当前文件由冲突状态

转换为已修改状态，待提交

#### 10.3.8 还原没有提交的提交的代码

a) team	还原

#### 10.3.9 还原已经提交的代码

a) 如果最新的代码出现问题，可以直接修改，也可以回滚到之前的某个历史版本，直接使用或者进行修改

b) 查看资源历史记录

c) 根据注释确定要还原的版本，无法确定可以查看或者比较代码

d) 确定版本后，右键选择”从修订班x 回复更改”

e) 可能出现冲突，解决后提交代码到服务器


# Bug 与 技巧

1. 使用 try catch 提高程序健壮性。列如在 servlet 中接受数字类型参数，需要格式转换，这时可以使用 trycatch语句，防止传入的参数有 null 和 空字符串或者其他的字符等等。

```java
//获取请求参数
// 1.1 获取每页的记录数
String sSize = req.getParameter("size");
int size = 5; //每页记录数
try{
    size = Integer.valueOf(sSize);
}catch(NumberFormatException e){
    e.printStackTrace();
}
// 1.2 获取页码索引
String sIndex = req.getParameter("index");
int index = 1;//页码索引 
try {
    index = Integer.valueOf(sIndex);  //null ," "				
} catch (Exception e) {
    e.printStackTrace();
}	
// 1.3 获取当前成绩
String sScore = req.getParameter("score");
Double score = 0.0;		 		
if(sScore == null || sScore.equals("")){
    sScore = "";
}
try{
    score = Double.parseDouble(sScore);
}catch(NumberFormatException e){
    e.printStackTrace();
}
// 1.4 获取学生姓名
String name = req.getParameter("name");
```

