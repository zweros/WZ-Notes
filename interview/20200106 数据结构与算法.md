title: 20200106 数据结构与算法
date: 2020-01-06

学习过程： 是什么？为什么？怎么用？

[数据结构可视化工具网站](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

[TOC]

## 时间复杂度和空间复杂度

### 时间复杂度

**大** **O** **时间复杂度**实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间**随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，**简称时间复杂度**。

```java
int sum(int n) {
     int sum = 0;//执行一遍
     for (int i=1; i <= n; ++i) { //执行 n 遍
         for (int j=1; j <= n; ++j) { //执行 n*n 遍
              sum = sum + i * j;//执行 n*n 遍
         }
	 } 
}

// 假设每条代码执行的时间 Timer 
// 时间复杂度为 T(n) = O(n*n+n+1)*Timer => T(n) = (n^2)
```

**计算时间复杂度原则**

1. 代码循环次数最多原则

   ```java
   int test(int n){
       int sum=0;
       int i=0; 
       for (;i<n;i++){
           sum + = i; // 循环内执行次数最多，n 次 因此 这段程序的时间复杂度记为 O(n)
       }
       return sum;
   }
   ```
   
2. 加法原则

   ```java
   int sum(int n) {
        // 常量级：忽略
        int sum_1 = 0; 
        int p = 1; 
        // 因为值循环了 100 次，属于常量级：忽略
        for (; p <= 100; ++p) { 
      	  sum_1 = sum_1 + p; 
        }
        // 常量级：忽略
        int sum_2 = 0; 
        int q = 1; 
   
        //循环 n 次，时间复杂度为：O(n)
        for (; q < n; ++q) {
       	 sum_2 = sum_2 + q;
        }
       // 常量级：忽略
        int sum_3 = 0;
        int i = 1;
        int j = 1;
        //嵌套循环，时间复杂度为：O(n*n)
        for (; i <= n; ++i) {
            j = 1; 
            for (; j <= n; ++j) {
           	 sum_3 = sum_3 + i * j;
            }
        }
        return sum_1 + sum_2 + sum_3; 
   }
   
   // 时间复杂度
   
   ```

3. 乘法原则

   ```java
   int sum(int n) {
        int ret = 0; 
        int i = 1;
        //单独看是:O(n),由于 func(i)是 O(n)因此整体是:O(n) * O(n) = O(n*n) = O
       (n*n)
        for (; i < n; ++i) {
        	ret = ret + func(i);//f(i)是 O(n)
        } 
       } 
       // O(n)
       int func(int n) {
            int sum = 0;
            int i = 1;
            for (; i < n; ++i) {
            sum = sum + i;
        } 
        return sum;
   }
   ```

**常见的时间复杂度**

1. O(1)  常数阶

   ```java
   public void test2(){	 
   	 int i=0;
        int sum=0;
        for(;i<100;i++){
        sum = sum+i;
        }
        System.out.println(sum);
   }
   ```

2. O(n) 

   ```java
   public void test03(int n){
    int i=0;
    int sum=0;
    for(;i<n;i++){
    sum = sum+i;
    }
    System.out.println(sum);
   }
   ```

3. O(logn) 和 O(nlogn)

   根据换地公式 $log_ab * log_bN = log_aN$ ，由此推导出 $log_3N * log_2n = log_3n$ 。

   当对数阶时间复杂度中我们忽略对数的底统一表示为： O(logn) 

   ```java
   public void test05(int n){
    int i=1;
    while(i<=n){   // 当循环到第 k 次， i == n 时， 3^K = 3n => k = log_33n
   	 i = i * 3;  
    } 
   }
   // 分析      
   // 1    1*3=3     3^1 
   // 3    3*3=9     3^2
   // 9    9*3=27    3^3
   // ...  
   // n    n*3=3n    3^k    第 k 次后 =>  3^k = n => k = log3n 
    public void test06(int n){
    int i=0;
    for(;i<=n;i++){
   	 test04(n);
    }
   }
   public void test07(int n){
    int i=1;
    while(i<=n){
    	i = i * 2;
    } 
   }
   ```

### 最好、最坏、平均时间复杂度



### 空间复杂度

O(1)、O(n)、O(n*n)

### 时间复杂度和空间复杂度的总结

时间复杂度和空间复杂度都是衡量算法性能的优劣

## 什么是数据结构？什么是算法？

数据结构：描述数据存储在计算机中的结构，分为逻辑结构和物理结构

算法：操作数据的方法，也解决问题的方法或者步骤

## 线性表

只有一个直接前继和直接后驱，列如：数组、链表、栈、队列等

![](http://img.zwer.xyz/blog/20200106170559.png)



## 数组

### 数组的概念

数组是属于线性表结构，**占用一段连续内存空间、存储相同类型的数据**，并且每个数据占用相同大小内存空间

在 Java 中，数组有个很重要的属性： `length` ，用表示数组的长度

### 数组的逻辑结构和物理结构

- 逻辑结构

  逻辑结构就是数学表示方式，比如数组 a ，有 n 个元素，则a  =（a0、a1、a2...aN）

- 物理结构

  数组存储在计算机中的结构

  ![](http://img.zwer.xyz/blog/20200106170651.png)

 在 Java 中为什么数组的下标从 0 零开始？

（1）从数组寻址来说，确定数组中元素的位置由下面的公式计算出来：

```
元素对应的内存地址 = 数组内存起始地址 + index(下标/索引) * 数组指定类型的大小 
```

若数组下标为 0 ，则正好等于数组中第一个元素的内存地址。

若采用数组下标从 1 开始，则计算数组中元素的位置的公式为

```
元素对应的内存地址 = 数组内存起始地址 + (index-1) * 数组指定类型的大小
```

也就是说每次从数组取数据都要加上减法运算，效率降低

（2）从历史角度来说，C 语言设计者默认数组下标就是从 0 开始

### 数组的特点

1. 相对高效的随机访问

2. 相对低效的插入删除

   ![](http://img.zwer.xyz/blog/20200107093212.png)

   

### 数组的应用之 ArrayList 源码分析

（1）ArrayList 是 Java 中对数组这种数据结构提供了对数组的增加、删除等封装操作，其中重要的一点实现提供数组**动态扩容** 的机制

（2）ArrayList 中 add 方法源码分析

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final int DEFAULT_CAPACITY = 10;
    private static final Object[] EMPTY_ELEMENTDATA = {};
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    transient Object[] elementData;
    private int size;

    public ArrayList() { // 默认创建一个长度为0，类型 Object 类型的空数组
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
    
    public boolean add(E e) {// 添加元素方法
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
    
    private void ensureCapacityInternal(int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // 10
        }
        ensureExplicitCapacity(minCapacity);
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity); // 若空间不足，则进行数组扩容
    }
    
     private void grow(int minCapacity) { // 数组扩容方法	
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```

（3）ArrayList 中  add 方法源码分析结论

1. 初始化无参 ArrayList 构造方法，默认开辟长度为 0，类型 Object 的数组。
2. 当初始化 ArrayList 无参构造方法，第一次使用 add 方法，数组会扩容长度变为 10
3. 当 ArrayList 中数组空间不足，数组会再次扩容，扩容的大小为原来的 0.5 倍



## 链表

### 链表的概念

链表是由一组非连续的内存空间组成，每个节点上存储数据和指向下一个元素的内存地址

### 链表的逻辑结构和物理结构

![](http://img.zwer.xyz/blog/20200106200946.png)

### 链表的类型

-  单链表

  ![](http://img.zwer.xyz/blog/20200107094001.png)

- 循环链表

- 双链表

- 双向循环链表

### 链表应用之 LinkedList 源码分析

- ListedList 中 add 方法

  ```java
  */
  public boolean add(E e) {
      linkLast(e);
      return true;
  }
  /**
    * Links e as last element.
   */
  void linkLast(E e) {
      final Node<E> l = last; // 指针 l 指向尾结点
      final Node<E> newNode = new Node<>(l, e, null); // 创建新结点
      last = newNode;
      if (l == null)
          first = newNode;
      else
          l.next = newNode;
      size++;
      modCount++;
  }
  
  /**
  *	 双链表
  */ 
  private static class Node<E> {
      E item;
      Node<E> next; 
      Node<E> prev;
  
      Node(Node<E> prev, E element, Node<E> next) {
          this.item = element;
          this.next = next;
          this.prev = prev;
      }
  }
  ```

- LinkedList 中 get 方法 

  ```java
  public E get(int index) {
      checkElementIndex(index);
      return node(index).item;
  }
  
  Node<E> node(int index) {
      // assert isElementIndex(index);	
  	//  通过 index 下标与链表
      if (index < (size >> 1)) {
          Node<E> x = first;
          for (int i = 0; i < index; i++)
              x = x.next;
          return x;
      } else {
          Node<E> x = last;
          for (int i = size - 1; i > index; i--)
              x = x.prev;
          return x;
      }
  }
  ```

### 链表笔试题之单链表转置

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;  // 前一个结点
        ListNode curr = head; // 指向当前结点
        // 遍历单链接,从头结点到尾结点，尾结点的.next = null 
        while(curr != null){
            // 暂存当前结点的下一个节点
            ListNode nextTemp = curr.next;
            // 将当前的下一个结点指向前一个结点
            curr.next = prev;
            // 将当前结点作为新的前一个结点（前指针指向当前结点）
            prev = curr;
            // 将 nextTemp 作为当前结点（当前指针指向下一个点）
            curr = nextTemp; 
        }
        return prev;
    }
}
```

## 栈

###  栈的概念

栈是一种受限的线性表，只允许一端操作，而另一端封闭。

栈的特点是**先进后出，后进先出**，即 LIFO ，Last in first out 

![](http://img.zwer.xyz/blog/20200107210949.png)



### 栈的实现

- 基于数组实现的顺序栈

  ```java
  package com.szxy.com.szxy.stack;
  
  /**
   * @Auther:zwer
   * @Date:2020/1/7 21:31
   * @Description:com.szxy.com.szxy
   * @Version:1.0
   * 基于数组实现栈
   **/
  public class ArrayStackDemo {
      public static void main(String[] args) {
          MyStack stack = new MyStack();
          // 入栈（压栈）
          for(int i=0; i < 13; i++){
              boolean flag = stack.push(i);
              System.out.println("push--"+i+"flag--"+flag);
          }
          // 出栈
          for(int i=0; i < 11; i++){
              Object obj = stack.pop();
              System.out.println("pop--"+obj);
          }
      }
  }
  
  /**
   *  栈
   */
  class MyStack{
      private int size = -1;
      private final int  DEFAULT_CAPACITY = 10;
      private Object[] element = new Object[DEFAULT_CAPACITY];
  
      public MyStack(){
      }
  
      public boolean push(Object obj){
          try{
              checkCapacity(size+1);
              element[++size] = obj;
              return true;
          }catch (RuntimeException e){
              // e.printStackTrace();
              return false;
          }
      }
  
      private void checkCapacity(int minCapacity){
          if(minCapacity >= this.DEFAULT_CAPACITY){
              throw new RuntimeException("stack overflow "+minCapacity);
          }
      }
  
      public Object pop(){
          if(size > -1){
              Object val = this.element[size];
              this.element[size--] = null;
              return val;
          }
          return null;
      }
  }
  ```

- 基于链表实现的链式栈

  ```java
  package com.szxy.com.szxy.stack;
  
  /**
   * @Auther:zwer
   * @Date:2020/1/8 16:17
   * @Description:com.szxy.com.szxy.stack
   * @Version:1.0
   * 基于链表形式的链式栈
   **/
  public class LinkedStack {
  
      private int size;   // 栈的大小，默认为 0 ，空栈
      private Node tail;  // 尾指针
  
      private static class Node{
          private Node prev;  // 前驱
          private Object data; // 存储结点中的值
          private Node next;  // 后继
  
          public Node(Node prev, Object data, Node next){
              this.prev = prev;
              this.data = data;
              this.next = next;
          }
      }
  
      public LinkedStack(){
          this.tail = null; // 变量初始化
      }
  
      /**
       * 入栈
       * @param data
       * @return
       */
      public boolean push(Object data){
            Node newNode = new Node(tail, data, null);
            if(tail != null){
                tail.next = newNode;
            }
            tail = newNode;
            size++;
          return true;
      }
  
      /**
       *  出栈
       * @return
       */
      public Object pop(){
          if(size > 0){
              Object result = tail.data;
              tail = tail.prev;
              //  切断下一个结点的连接
              if(tail != null){
                  tail.next = null;
              }
              size--;
              return  result;
          }
          return null;
      }
  
      /**
       * 测试
       * @param args
       */
      public static void main(String[] args) {
          LinkedStack stack = new LinkedStack();
          // 入栈（压栈）
          for(int i=0; i < 13; i++){
              boolean flag = stack.push(i);
              System.out.println("push--"+i+"  flag--"+flag);
          }
          // 出栈
          for(int i=0; i < 14; i++){
              Object obj = stack.pop();
              System.out.println("pop--"+obj);
          }
      }
  
  }
  ```

### 栈的应用之 Stack 源码分析

```java
public class Stack<E> extends Vector<E> {
    /**
     * Creates an empty Stack.
     */
    public Stack() {
        
    }
    // 入栈操作
    public E push(E item) {
        addElement(item);
        return item;
    }
    
    // 以下都是 Vector 类中的方法
    public synchronized void addElement(E obj) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = obj;
    }

    private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
    
    // 扩容
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                         capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
}
```

## 队列

### 队列的概念

队列是一种**先进先出**的数据结构，即 FIFO，First in  First out 

### 队列的逻辑结构和物理结构

![](http://img.zwer.xyz/blog/20200108173016.png)

### 队列的实现

- 顺序队列

  ```java
  /**
   * @Auther:zwer
   * @Date:2020/1/8 20:06
   * @Description:com.szxy.com.szxy.queen
   * @Version:1.0
   * 基于数组实现的顺序队列
   **/
  public class ArrayQueue {
      // 数组的长度
      private int  size;
      // 默认初始化数组的默认长度
      private final int DEFAULT_SIZE=10;
      // Object 类型数组
      private Object[] elements;
      // 数组最大长度
      private int MAX_ARRAY_SIZE= Integer.MAX_VALUE - 8;
      // 队头指针
      private int head;
      // 队尾指针
      private int tail;
  
      public ArrayQueue(){
          this.elements = new Object[this.DEFAULT_SIZE];
          // 初始化队头队尾指针
          initPoint(0,0);
      }
  
      public ArrayQueue(int capacity){
          if(capacity <= 0){
              throw new RuntimeException("capacity less then 0");
          }
          this.elements = new Object[capacity];
          initPoint(0,0);
      }
  
      /**
       * 初始化队头队尾指针
       * @param head  头指针
       * @param tail  尾指针
       */
      private void initPoint(int head, int tail){
          this.head = head;
          this.tail = tail;
      }
  
      // 操作队头队尾指针
      public boolean enQueue(Object data){
          // 检查数组容量是否可以满足
          ensureArrayCapacity();
          // 添加元素
          elements[tail++] = data;
          size++;
          return true;
      }
  
  
      private void ensureArrayCapacity(){
          // 当尾指针到达数组末端
          if(tail == elements.length){
              // 判断数组中是否还有可用空间
              if (size < elements.length){
                  if(head == 0){
                      // 扩容
                      grow(elements.length);
                  }else{
                      // 将数组元素向前移动
                      for(int i=head; i < tail; i++){
                          elements[i-head] = elements[i];
                      }
                      // 初始化指针
                      initPoint(0, tail - head);
                  }
              }
          }
      }
  
      /**
       *  扩容
       * @param oldCapacity
       */
      private void grow(int oldCapacity){
          int newCapacity = oldCapacity + (oldCapacity >> 1); // 扩容 1.5 倍
          if(newCapacity - oldCapacity < 0){
              newCapacity = this.DEFAULT_SIZE;
          }else if(newCapacity - Integer.MAX_VALUE > 0){
              newCapacity = newCapacity > Integer.MAX_VALUE? MAX_ARRAY_SIZE : newCapacity;
          }
          Arrays.copyOf(elements,newCapacity);
      }
  
      /**
       *  出队列
       * @return
       */
      public Object deQueue(){
          if(tail > elements.length){
              return null;
          }
          Object element = elements[head++];
          size--;
          return element;
      }
  
      public int getLength(){
          return this.elements.length;
      }
  
      public static void main(String[] args) {
          ArrayQueue queue = new ArrayQueue();
          System.out.println(queue.getLength());
          for (int i=0; i < 10; i++){
              queue.enQueue(i);
          }
          queue.enQueue(11);
          // 出队列
  //        for (int i=0; i < 10; i++){
  //            Object obj = queue.deQueue();
  //            System.out.println(i+" "+obj);
  //        }
      }
  }
  ```

- 链式队列

  ```java
  package com.szxy.com.szxy.queen;
  
  /**
   * @Auther:zwer
   * @Date:2020/1/8 22:10
   * @Description:com.szxy.com.szxy.queen
   * @Version:1.0
   * 基于链表形式实现的队列
   **/
  public class LinkedListQueue {
      // 链表中元素个数
      private int size;
      // 头指针
      private Node head;
      // 尾指针
      private Node tail;
  
      public LinkedListQueue(){
          this.head = null;
          this.tail = null;
      }
  
      // 入队列
      public boolean enQueue(Object data){
          Node newNode = new Node(data,null);
          if(tail == null){
              head = newNode;
          }else{
              tail.next = newNode;
          }
          tail = newNode;
          size++;
          return true;
      }
  
      public Object deQueue(){
          if(head == null){
              return null;
          }
          Object data = head.data;
          head = head.next;
          if(head == null){
              tail = null; // 头尾指针相连
          }
          return data;
      }
  
      private static class Node{
          private Object data;
          private Node next;
          public Node(Object data, Node next){
              this.data =data;
              this.next = next;
          }
      }
  
      /**
       * 测试
       * @param args
       */
      public static void main(String[] args) {
          LinkedListQueue queue = new LinkedListQueue();
          for (int i = 0; i < 10; i++){
              boolean flag = queue.enQueue(i);
              System.out.println("enqueue--"+i+"  "+flag);
          }
          for (int i = 0; i < 10; i++){
              Object data = queue.deQueue();
              System.out.println("dequeue--"+i+"  "+data);
          }
  
      }
  
  }
  ```

### 队列的应用

首先我们得回顾本章开始所讲到的队列的特点：先进先出(FIFO)，一般情况下，如果是对一些及时消息的处理，并且处理时间很短的情况下是不需要队列的，直接阻塞式的方法调用就可以了。但是如果在消息处理的时候特别费时间，这个时候如果有新消息来了，就只能处于阻塞状态，造成用户等待。这个时候便需要引入队列了。当接收到消息后，先把消息放入队列中，然后再用新的线程进行处理，这个时候就不会有消息阻塞了。所以队列用来存放等待处理元素的集合，这种场景一般用于缓冲、并发访问，及时消息通信，分布式消息队列等



## 递归算法

### 递归的概念

递归分为递和归。 递归其实就是函数自身调用自己，只是传递的参数的不同

**满足递归的条件（掌握）**

1. 递归表达式（规律）
2. 终止递归的条件（递归出口）

综上所述：写递归代码的关键就是找到如何将一个问题拆分成多个小问题的规律，并且基于此写出递推公式，然后再找到递归终止条件，最后将递推公式和终止条件翻译成代码即可。

**递归和循环**

使用迭代循环的方式将递归改写为非递归代码。

循环都可以改写递归，递归未必能改写成循环。

### 递归的引用

**阶乘问题**

```java
package com.szxy.recursion;

import java.math.BigInteger;

/**
 * @Auther:zwer
 * @Date:2020/1/9 17:30
 * @Description:com.szxy.recursion
 * @Version:1.0
 * 递归之阶乘
 **/
public class FactorialDemo {

    /**
     * int 类型的阶乘
     * @param n
     * @return
     */
    public static int factorial(int n){
        if(n == 1){
            return 1;
        }
        return n * factorial(n-1);
    }

    /**
     * 计算大整型数的阶乘
     * @param n
     * @return
     */
    public static BigInteger bigIntegerFactorial(int n){
        if(n == 1){
            return BigInteger.ONE;
        }
        return BigInteger.valueOf(n).multiply(BigInteger.valueOf(n-1));
    }

    /**
     * 测试
     * @param args
     */
    public static void main(String[] args) {
        int result = factorial(100);
        System.out.println("result="+result); // ... 结果不正确
        BigInteger result2 = bigIntegerFactorial(100);
        System.out.println("result2="+result2);
    }
}
```

## 排序算法

### 冒泡排序

**冒泡排序代码实现**

```java
/**
 * @Auther:zwer
 * @Date:2019/12/30 15:49
 * @Description:com.szxy.sort.bubble
 * @Version:1.0
 * 冒泡排序
 * 时间复杂度: o(n^2)
 **/
public class BubbleSortDemo {
    public void bubbleSort(int[] arr) {
        // 如果数组的长度等于 1，则直接返回
        if(arr.length == 1) return;

        // 外层循环控制每次数组循环的次数
        for (int i = 0; i < arr.length; i++) {
            boolean flag = true; // 优化，若已经有序，则直接跳出循环
            // 内层循环控制每次循环元素间比较的次数
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    flag = false;
                }
            }
            System.out.println("temp: " + i + " " + Arrays.toString(arr));

            if (flag) break;  //跳出循环

        }

    }

    @Test
    public void testBubbleSort() {
        int[] arr = new int[]{5, 2, 6, 9, 0, 3};
        System.out.println(Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```

**冒泡排序总结**

```
1：冒泡排序的时间复杂度是多少？
最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可
以结束了，所以
最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列
的，我们需要进行 n
次冒泡操作，所以最坏情况时间复杂度为 O(n2)。 2：冒泡排序的空间复杂度是多少？
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间
复杂度为 O(1)，是一种 in-place 排序算法。
3：冒泡排序是稳定的排序算法吗？
在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法
的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据
在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
```

### 插入排序

**插入排序原理**

插入排序(Insertion Sort)的原理是：将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是**取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序**。重复这个过程，直到未排序区间中元素为空，算法结束。

![](http://img.zwer.xyz/blog/20200109214103.png)



**插入排序代码**‘

```java
public class InsertSort {

    public static void insertSort(int[] arr){
        int length = arr.length;
        if(length <= 1) return;
        for(int i=1; i < length; i++){
            // 获取当前数组下标对应的值
            int currentValue = arr[i];
            // 获取数组下标的前一个元素
            int preIndex = i - 1;
            while(preIndex >= 0 && arr[preIndex] > currentValue){
                arr[preIndex+1] = arr[preIndex];
                preIndex--;
            }
            arr[preIndex+1] = currentValue;
        }
    }
    
    // 测试
    public static void main(String[] args) {
        int[] arr = new int[]{5, 2, 6, 9, 0, 3};
        System.out.println(Arrays.toString(arr));
        insertSort(arr);
        System.out.println(Arrays.toString(arr));
    }

}

```

**插入排序总结**

```
1：插入排序的时间复杂度是多少？
如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好时间复杂度为 O(n)。
注意，这里是从尾到头遍历已经有序的数据。
如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n2)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)。

2：插入排序的空间复杂度是多少？
从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所
以空间复杂度是 O(1)，也就是说，这是一个 in-place【原地排序】排序算法。

3：插入排序是稳定的排序算法吗？
在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法
```



###  选择排序

**选择排序原理**

每次从数组中找出最小值，在数组已排序的尾端（最开始的尾端为下标为 0 ）添加

**选择排序实现**

```java
/**
 * @Auther:zwer
 * @Date:2020/1/9 22:01
 * @Description:com.szxy.sort.selection
 * @Version:1.0 选择 排序
 **/
public class SelectionSort {

    public static void selectionSort(int arr[]) {
        int length = arr.length;
        if (length <= 1) return;
        for (int i = 0; i < length; i++) {
            // 设置当前数组下标为最小值
            int minIndex = i;
            // 找出数组中最小值的下标
            for (int j = i + 1; j < length; j++) {
                if (arr[minIndex] > arr[j]) {
                    minIndex = j;
                }
            }
            // 将数组中最小值与当前值位置进行交换
            int current = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = current;
        }
    }

    // 测试
    public static void main(String[] args) {
        int[] arr = new int[]{5, 2, 6, 9, 0, 3};
        System.out.println(Arrays.toString(arr));
        selectionSort(arr);
        System.out.println(Arrays.toString(arr));
    }

}

```

**选择排序总结**

```
1：选择排序的时间复杂度是多少？
结合之前的分析方式分析可知选择排序的最好情况时间复杂度为 O(n2)，最坏情
况时间复杂度为:O(n2)，平均情况下的时间复杂度为：O(n2)。 


2：选择排序的空间复杂度是多少？
通过算法的实现我们可以发现，选择排序的空间复杂度为 O(1)，是一个 in-place
排序算法


3：选择排序是一个稳定的排序算法吗？
注意：选择排序不是一个稳定的排序算法，为什么呢？选择排序每次都要找剩余
未排序元素中的最小值，并和未排序区间的第一个元素进行交换位置，这样破坏了
稳定性，比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第
一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，
所以就不稳定了。正是因此，从稳定性上来说选择排序相对于冒泡排序和插入排序
就稍微逊色了
```

### 快速排序

> 采用分而治之的思想

- 快速排序的原理

  给定一组数据，选取一个分区点（prvot）作为中间值，比分区点值大的放在右边，比分区点值小的放在左边，然后再对左边和右边选取新的分区点，继续再原来的方式排列，直到所有数组按顺序排列大小为止

- 代码实现

  ```java
	package com.szxy.sort;
    import java.util.Arrays;
  
  /**
       * @Auther:zwer
       * @Date:2019/12/29 20:42
       * @Description:com.szxy.sort
       * @Version:1.0 快速排序
       * 最好情况时间复杂度为 O(n2)，最坏情况时间复杂度为:O(n2)，平均情况下的时间复杂度为：O(n2)。
       * 空间复杂度为 O(1)，是一个 in-place序算法
          **/
  
  public class QuickSortTest {
      /**
           * 快速排序
           * @param arr
           * @param start
           * @param end
           */
      public void quickSort(int[] arr, int start, int end) {
          // 递归出口
          if(arr.length <= 1 || start >end) return;
          int pivotIndex = partition(arr, start, end);
          // 左分区
          quickSort(arr,start,pivotIndex-1);
          // 右分区
          quickSort(arr,pivotIndex+1, end);
      }
  
      // 分区
      public int partition(int[] arr, int start, int end) {
          // 选取 end 位置作为默认的分区点
          int pivot = arr[end];
          // 寻找分区点对应的索引下标
          int pivotIndex = start;
          for (int i = start; i < end; i++) {
              if(arr[i] < pivot){
                  if(i > pivotIndex){
                      swap(arr,i,pivotIndex);
                  }
                  pivotIndex++;
              }
              //System.out.println(Arrays.toString(arr));
          }
          swap(arr,end,pivotIndex);
  
          return pivotIndex;
      }
  
      /**
           * 数值交互
           *
           * @param arr
           * @param i
           * @param j
           */
      public void swap(int[] arr, int i, int j) {
          int temp = arr[j];
          arr[j] = arr[i];
          arr[i] = temp;
      }
      /**
           * 测试
           *
           * @param args
           */
      public static void main(String[] args) {
          int[] arr = new int[]{0, 3, 5, 7, 2, 4, 9, 6};
          System.out.println(Arrays.toString(arr));
          new QuickSortTest().quickSort(arr, 0, arr.length-1);
          System.out.println(Arrays.toString(arr));
      }
  
  }

  ```

### 归并排序

 - 归并排序思想

     采用分而治之的方法

     第一步：拆分(采用递归的方式拆分)

     第二步：合并（采用合并两个有序数组的方式合并）

- 代码实现

  ```java
  
  /**
   * 归并排序算法
   *  归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，
   *  然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了
   */
  public class MergeSort {
      public int[] mergeSort(int[] arr){
  
          if (arr.length<2){
              return  arr;
          }
          //将我们的数组拆分成两个部分
          int mid = arr.length/2;
          int [] left = Arrays.copyOfRange(arr,0,mid);
          int [] right = Arrays.copyOfRange(arr,mid,arr.length);
  
          //  分解并合并
          return merge(mergeSort(left),mergeSort(right));
  
      }
      /**
       * 合并两个有序数组并返回新的数组
       * @param left
       * @param right
       */
      public int[] merge(int[] left,int[] right){
  
          // 创建一个新的数组，这个数组的长度等于两个数组长度之和
          int [] newArray = new int[left.length+right.length];
          //  定义两个指针分别代表两个数组的下标
          int lindex = 0;
          int rindex = 0;
          for (int i=0; i< newArray.length;i++){
              if (lindex>=left.length){
                  newArray[i]=right[rindex++];
              } else  if (rindex>=right.length){
                  newArray[i] =left[lindex++];
              } else if(left[lindex] <right[rindex]){
                  newArray[i] = left[lindex++];
              } else {
                  newArray[i] = right[rindex++];
              }
          }
          return  newArray;
      }
  
      @Test
      public void testInsertionSort1(){
          //准备一个int数组
          int[] array = new int[6];
          array[0] = 5;
          array[1] = 2;
          array[2] = 6;
          array[3] = 9;
          array[4] = 0;
          array[5] = 3;
          //进行排序
          System.out.println(Arrays.toString(array));
          array = mergeSort(array);
          //输出排序结果
          System.out.println(Arrays.toString(array));
      }
  }
  ```

### 桶排序

**桶排序的原理**

将集合中的元素按照一定的规则划分到不同的桶中，然后将对每个桶中的元素进行排序（快速排序或者递归桶排序），再将桶中的元素放入结果集合中存放。

**桶排序的实现**

```java
/**
 * @Auther:zwer
 * @Date:2020/1/10 10:32
 * @Description:com.szxy.sort.bucket
 * @Version:1.0
 * 桶排序
 **/
public class BucketSort {

    /**
     *
     * @param arr   待排序的集合
     * @param bucketSize 人为指定的桶中存放元素的个数，但是容量不限
     * @return
     */
    public static List<Integer> bucketSort(List<Integer> arr, int bucketSize){

        // 合法性检查
        if(arr == null || arr.size() < 2 || bucketSize < 1)  return arr;

        // 找出集合中元素的最大值和最小值
        int minValue = arr.get(0);
        int maxValue = arr.get(0);
        for(int i = 1; i < arr.size(); i++){
            if(minValue > arr.get(i)) minValue = arr.get(i);
            if(maxValue < arr.get(i)) maxValue = arr.get(i);
        }

        // 根据集合中元素的最大值和最小值以及桶的大小确定桶的个数
        int bucketCount = (maxValue-minValue)/bucketSize+1;

        // 创建桶
        List<List<Integer>> bucketList = new ArrayList<List<Integer>>();
        for (int i = 0; i < bucketCount; i++){
            bucketList.add(new ArrayList<Integer>());
        }

        // 将集合中的元素划分到不同的桶中
        for (int i = 0; i < arr.size(); i++){
            int bucketIndex = (arr.get(i)-minValue)/bucketSize;
            bucketList.get(bucketIndex).add(arr.get(i));
        }

        // 存放最后的结果
        List<Integer>  resutlList = new ArrayList<Integer>();
        // 将每个桶中的元素进行排序
        for (int i = 0; i < bucketCount; i++){
            List<Integer> everyBucket = bucketList.get(i);
            // 如果桶中有元素
            if(everyBucket.size() > 0){
                // 如果桶的只有一个，则将桶的大小减一，目的是分更多的桶，避免将数据都放入同一个桶中
                if(bucketCount == 1){
                    bucketSize--;
                }
                // System.out.println("everyBucket:"+everyBucket);
                List<Integer> tmpList = bucketSort(everyBucket, bucketSize);
                for (Integer element : tmpList) {
                    resutlList.add(element);
                }
            }
        }
        return resutlList;
    }

    public static void main(String[] args) {
        List<Integer>  arr= new ArrayList<Integer>();
        arr.add(5);
        arr.add(2);
        arr.add(10);
        arr.add(6);
        arr.add(9);
        arr.add(0);
        arr.add(3);
        arr.add(4);
        System.out.println(arr);
        List<Integer> result = bucketSort(arr, 2);
        System.out.println(result);

    }
}
```

**桶排序总结**

桶排序的速度很快，但占用的空间大。

```
1：桶排序的时间复杂度是多少？
桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，如果我们将待排序元素映射到某一个桶的映射规则做的很好的话，很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。我们一般对每个桶内的元素进行排序时采用快排也可以采用递归桶排序，通过我们刚开始的分析，当我们对每个桶采用快排时如果桶的个数接近数据规模 n 时，复杂度为 O(n)，如果在极端情况下复杂度退化为 O(n* log n)。 

2：桶排序的空间复杂度是多少？
由于需要申请额外的空间来保存元素，并申请额外的空间来存储每个桶，所以空间复杂度为 O(N+M)，其中 M 代表桶的个数。所以桶排序虽然快，但是它是采用了用空间换时间的做法。


3：桶排序是稳定的排序算法吗？
桶排序是否稳定取决于对每一个桶内元素排序的算法的稳定性，如果我们对桶内元
素使用快排时桶排序就是一个不稳定的排序算法。
```

### 计数排序

**计数排序原理**

统计数组中每个元素出现的次数，使用额外的数组存放这些信息，最后遍历额外数组，输出新数组

**计数排序实现**

```java
/**
 * @Auther:zwer
 * @Date:2020/1/10 11:33
 * @Description:com.szxy.sort
 * @Version:1.0
 * 计数排序
 **/
public class Countingsort {

    /**
     * @param arr 待排序的数组
     */
    public static void  countingSort(int arr[]){
        // 合法性校验
        int len = arr.length;
        if(arr == null || len < 2) return;

        int minValue = arr[0];
        int maxValue = arr[0];
        for (int i = 1; i < len; i++){
            if(minValue > arr[i])  minValue = arr[i];
            if(maxValue < arr[i])  maxValue = arr[i];
        }
        // 开辟计数数组的大小
        int newArrSize = (maxValue-minValue)+1;
        int[] newArr = new int[newArrSize];

       //统计对应元素的个数,数组的下标不是单纯的值
        for (int i = 0; i < len; i++){
            int index = arr[i] - minValue;
            newArr[index] ++;
        }

        // 对数组中元素的个数进行累加
        for(int i = 1; i < newArrSize; i++){
            newArr[i] = newArr[i] + newArr[i-1];
        }

        // 创建临时数组，存放最终有序的数据列表
        int[] temp = new int[len];
        for(int i = len-1; i >= 0; i--){
            int index = arr[i] - minValue;
            temp[newArr[index]-1] = arr[i];
            newArr[index]--;
        }

        for(int i = 0; i < len; i++){
            arr[i] = temp[i];
        }

    }

    public static void main(String[] args) {
        int[] arr = new int[]{5, 2,2, 6, 9, 10, 3};
        System.out.println(Arrays.toString(arr));
        countingSort(arr);
        System.out.println(Arrays.toString(arr));
    }


}
```

**计数排序总结**

```
1：计数排序的时间复杂度是多少？
通过代码的实现过程我们发现计数排序不涉及元素的比较，不涉及桶内元素(数组C)的排序，只有对待排序数组和用于计数数组的遍历操作，因此计数排序的时间复杂度是 O(n+k)，其中 k 是桶的个数即待排序的数据范围，是一种线性排序算法。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C 的长度 k 取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

2：计数排序的空间复杂度是多少？
在计数排序的过程中需要创建额外的桶空间(数组 C)来计数，因此我们可以得知 计数排序的口空间复杂度为：O(n+K)，其中 n 是数据规模大小，K 是计数排序中需要的桶的个数，其实也就是用来计数的数组 C 的长度，之前我们提到过它取决于待排序数组中数据的范围。

3：计数排序是稳定的排序算法吗？
在计数排序中核心操作中我们是逆序的去扫描待排序数组，这样仍然可以使待排序数组中值相同但是位置靠后的元素在最终的已排序数组中保持着相同的位置关系，因此计数排序是一个稳定的排序算法。

4：计数排序的适用场景？
计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。
比如，还是拿分数这个例子。如果分数精确到小数后一位，我们就需要将所有的数都先乘以 10，转化成整数，然后再放到桶内。再比如，如果要排序的数据中有负数，数据的范围是[-100, 100]，那我们就需要先对每个数据都加 100，转化成非负整数。
```

## 小结

![](http://img.zwer.xyz/blog/20200110161126.png)

## 二分查找

> 二分查找又称为折半查找

### 二分查找的原理

> **二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为**  0

二分查找作用在已排序的数组或者集合

二分查找的中间值：

1. 如果元素的个数是奇数个，则取中间的元素的为中位数 mid 
2. 如果元素的个数是偶数个，则取中间 两个元素中较小的元素为中位数 mid

![](http://img.zwer.xyz/blog/20200110212625.png)



### 二分查找的时间复杂度

二分查找的时间复杂度： $O(log_2n)$, 比常数阶 $O(1)$还要小，所以说二分查找的效率很高。

###  二分查找的实现

**基本的二分查找**

1. 使用  while 循环实现的二分查找
2. 使用递归实现的二分查找

```java
/**
 * @Auther:zwer
 * @Date:2020/1/10 16:37
 * @Description:com.szxy.binarySearch
 * @Version:1.0
 * 二分查找实现：
 *  1. 使用 while 循环
 *  2. 使用递归
 * 需求：查找已排序的数组且数组中元素不重复
 **/
public class SingleBinarySearch {

    /**
     * 使用 while 循环进行二分查找
     * @param arr   已排序的数组
     * @param targetValue 需求查找的目标值
     * @return  boolean  true|false
     */
    public static boolean binarySearch(int[] arr,int targetValue){
        int low = 0;
        int high = arr.length-1;
        // 求中间位置
        // int mid = (low+high)/2;
        int mid = low + ((high-low) >> 2); // 效率更高
        while(low <= high){
            if(arr[mid] == targetValue) {
              return true;
            }else if(targetValue > arr[mid]){
                low = mid+1;
            }else{
                high = mid-1;
            }
            mid = (low+high)/2;
        }
        return false;
    }

    /**
     * 基于递归方式实现二分查找
     * @param arr   已排序的数组
     * @param targetValue 需求查找的目标值
     * @param low  区间内最小值索引下标
     * @param high 区间内最大值索引下标
     * @return boolean true|false 若查找到 targetValue ，则返回 true，否则返回 false
     */
    public static boolean recursionBinarySearch(int[] arr,int targetValue,int low,int high){
        if(low <= high){
            // 取中间位置 mid
            int mid = (low+high)/2;
            if(arr[mid] == targetValue){
                return true;
            }else if(arr[mid] > targetValue){
                return recursionBinarySearch(arr,targetValue,low,mid-1);
            }else{
                return recursionBinarySearch(arr,targetValue,mid+1,high);
            }
        }
        return false;
    }

    /**
     * 测试二分查找
     * @param args
     */
    public static void main(String[] args) {
        int[] arr = {1,10,15,20,21,36,30,40};
        boolean flag = binarySearch(arr,15);
        //boolean flag = recursionBinarySearch(arr, 19, 0, arr.length-1);
        System.out.println("flag="+flag);
    }
}

```

**需求1:**

```java
/**
 * 需求1：从数据序列中查找第一个值等于给定值的元素
 * @param arr  有序的数组
 * @param targetValue 需求查找的值
 * @return index -1(查找成功返回的结果) | x(查找成功对应的数组下标)
 */
public  static int binarySearch(int[] arr,int targetValue){
    int low = 0;
    int high = arr.length-1;
    while(low <= high){
        int mid = (high+low)/2;
        if(arr[mid] == targetValue){
            // 由于数据序列是有序的,因此我们向前一位查看一下是否也等于该值
            // 如果相等则继续二分查找,否则直接返回 mid
            if(mid == 0 || arr[mid-1] != targetValue){
                return mid;
            }else{
                high = mid-1;
            }
        }else if(arr[mid] < targetValue){
            low = mid+1;
        }else{
            high = mid-1;
        }
    }
    return -1;
}
```
**需求2**：

```java
/**
     * 需求2： 从数据序列中查找最后一个值等于给定值的元素
     * @param arr 有序的数组
     * @param targetValue 需要查找的值
     * @return index -1(查找成功返回的结果) | x(查找成功对应的数组下标)
     */
public static int binarySearch2(int[] arr,int targetValue){
    int low = 0;
    int high = arr.length - 1;
    // 如果 low 指针下标小于等于 high 指针下标
    while(low <= high){
        int mid = (high+low)/2;
        if(arr[mid] == targetValue){
            // 当中间指针是最后一个元素时或者
            // 中间指针的后一个元素的值不等于中间指针对应的值时返回中间指针mid
            if(mid == arr.length-1 || arr[mid+1] != targetValue)
                return mid;
            else
                low = mid+1;
        }else if(arr[mid] > targetValue){
            high = mid-1;
        }else{
            low = mid+1;
        }
    }
    return -1;
}

```

**需求3：**

```java
/**
* 需求3： 从数据序列中查找第一个大于等于给定值的元素
* @param arr 有序的数组
* @param targetValue  目标值
* @return index -1(查找成功返回的结果) | x(查找成功对应的数组下标)
*/
public static int binarySearch3(int[] arr,int targetValue){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int mid = (high+low)/2;
        if(arr[mid] >= targetValue){
            if(mid == 0 || arr[mid-1] < targetValue) return mid;
            else  high = mid-1;
        }else if(arr[mid] < targetValue){
            low = mid + 1;
        }
    }
    return -1;
}
```
**需求4:**

```java
/**
 * 需求 4： 从数据序列中查找出最后一个值小于等于给定值的元素
 * @param arr 序的数组
 * @param targetValue 目标值
 * @return index -1(查找成功返回的结果) | x(查找成功对应的数组下标)
*/
public static int binarySearch4(int[] arr, int targetValue){
    int low = 0;
    int high = arr.length - 1;
    while(low <= high){
        int mid = (high+low)/2;
        if(arr[mid] <= targetValue){
            // 当中间位置 mid 是最后一个元素或者当中间位置后一个元素大于目的值时，返回目标值
            if(mid == arr.length-1 || arr[mid+1] > targetValue) return mid;
            else low = mid + 1;
        }else if(arr[mid] > targetValue){
            high = mid - 1;
        }
    }
    return -1;
}
```

**二分查找总结**

1. 待查找的数据序列必须有序。如果待查找的数据序列无序，则先排序，再二分查找
2. 数据的存储依赖数组，数组按下表访问元素的时间复杂度为$O(1)$，而链表的复杂表是 $O(n)$ 
3. 数量太小或者太大都不适合二分查找。在数据量较小的特殊情况下可以使用二分查找寻找比较长的字符串

```
1：待查找的数据序列必须有序
二分查找对这一要求比较苛刻，待查找的数据序列必须是有序的，假如数据无序，那我们要先排序，然后二分查找，通过前面排序算法的学习我们知道，如果我们针对的是一组固定的静态数据，也就说该数据序列不会进行插入和删除操作，那我们完全可以先排序然后二分查找，这样子一次排序多次查找；但是如果数据序列本身不是固定的静态的，可能涉及数据序列的插入和删除操作，那我们每次查找前都需要进行排序然后才能查找，这样子成本非常的高。

2：数据的存储依赖数组
待查找的数据序列需要使用数组进存储，也就是说依赖顺序存储结构。那难道不能用其他的结构来存储待查找的数据序列吗？比如使用链表来存储，答案是不可以的，通过我们前面实现的二分查找的过程可知，二分查找，算法需要根据下标，low,high,mid 来访问数据序列中的元素，数组按照下标访问元素的复杂度是O(1)，而链表访问元素的时间复杂度是 O(n)，因此如果使用链表来存储数据二分查找的时间复杂度就会变得很高。

3：数据量太小或太大都不适合用二分查找
数据量很小的情况下，没有必要使用二分查找，使用循环遍历就够了，因为只有在数据量比较大的情况下二分查找才能体出优势，不过在某些情况下即使数据量很小也建议大家使用二分查找，比如数据序列中的数据都是一些长度非常长的字符串，这些长度非常长的字符串比较起来也会非常的耗时，所以我们要尽可能的减少比较的次数，这样反倒有助于提高性能。那为什么数据量太大的情况下也不建议使用二分查找呢？因为我们前面刚讲到二分查找底层需要依赖数组存储待查找的数据序列，而数组的特点是需要连续的内存空间，比如现在有 1G 的订单数据，如果用数组来存储就需要 1G 的连续内存，即便有 2G 的剩余内存空间，如果这 2G 的内存空间不连续那也无法申请到 1G 大小的
数组空间，所以我们说数据量太大也不适合用二分查找。
```



## 散列表

### 散列表的概念

散列表(Hash Table)又名哈希表/Hash 表，是根据键（Key）直接访问在内存存储位置的数据结构，它是由数组演化而来的，利用了数组支持按照下标进行随机访问数据的特性；



![](http://img.zwer.xyz/blog/20200111095652.png)

键通过散列函数转换为数组下标，在对应下标位置上存储相应信息

### 散列函数（掌握）

散列函数就是一个函数(方法)，能够将给定的 key 转换为特定的散列值，`key => HashValue`

我们可以表示为 `hashValue = hash(Key)`

基本要求：

1：散列函数计算得到的散列值必须是大于等于 0 的正整数，因为 hash 值需要作为数组的下标。
2：如果 key1== key2，那么经过 hash 后得到的哈希值也必相同即：hash(key1) == hash(key2)
3：如果 key1 != key2，那么经过 hash 后得到的哈希值也必不相同即：hash(key1) != hash(key2)

即 **hashValue 一定大于等于 0 且key 相同 hash 值相同，key 不同 hash 值不同**

好的散列函数的特点：

1：**散列函数不能太复杂**，因为太复杂度势必要消耗很多的时间在计算哈希值上，也会间接影响散列表性能。
2：散列函数计算得出的哈希值尽可能的能**随机并且均匀的分布**，这样能够将散列冲突最小化。

即 **散列函数不太复杂，并且得到的哈希值尽可能的随机均匀分布**

散列函数的设计方法：

1. 直接寻址法
2. 除留余数法
3. 平方取中法
4. 折叠法

### 散列冲突

> 两个不同的关键字（**key**），由于散列函数值相同，因而被映射到同一表位置上。
>
> 该现象称为散列冲突或哈希碰撞。

散列冲突的解决方案

（1） **开放寻址法**

1. 线性检测

   我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止

   ![](http://img.zwer.xyz/blog/20200111105733.png)

   

   2. 两次检测

      相比于线性检测而言，两次检测的步长为每次检测的步长变为原来的平方

   3. 双重检测

      相对原来使用一个 hash 函数，现在使用一组 hash 函数，如果一组中一个 hash 函数发生碰撞，则更换为其他 hash 函数

   ```
   装载因子：
   总之不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲位置。我们用装载因子(load factor)来表示空位的多少。
   
   散列表装载因子的计算公式为：
   装载因子 = 散列表中元素的个数 / 散列表的长度
   
   装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。那如果装载因子过大了怎么办？装载因子过大不仅插入的过程中要多次寻址，查找的过程也会变得很慢。当装载因子过大时，进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。
   
   插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。但是这个动态扩容的过程在 n 次操作中会遇见一次，因此平均下来时间复杂度接近最好情况，就是 O(1)。
   
   当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。
   
   总结一下，当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是Java 中的 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。
   ```

（2）**链表法**

> 在散列表中，数组的每个下标位置我们可以称之为“桶（bucket）”或者“槽（slot）”，每个桶(槽)会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。

![image-20200111112543113](D:\photo\TyporaPicture\image-20200111112543113.png)

**基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。**



企业级散列表具有的特点：

- 支持快速的查询、插入、删除操作；
-  内存占用合理，不能浪费过多的内存空间；
-  性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况


### 散列表的应用（掌握并应用）
HashMap 的数据结构图如下图所示：

![](http://img.zwer.xyz/blog/20200111162114.png)

jdk1.8 中关于 HashMap 的实现跟 jdk1.7 的几点差别：
1：数据结构引入了红黑树，好处是可以提高查询效率(jdk1.7 中极端情况下查询是 O(n)，如果引入红黑树在极端情况下的查询可以降低为 O(log n))，当散列表某一桶内链表节点数>=8 时链表树化成红黑树，红黑树太小时退化成链表，退化的阈值为 6

2：计算 key 的 hash 值的方式不一样，但是思路和原理一样都是对 key 的 hashCode 进行扰动让高位和低位一起参与运算计算出更加均匀的 hash 码，降低hash 冲突的概率。

3：插入数据时如果发送了 hash 冲突，优先判断该位置上是否是红黑树，如果是则存入红黑树中如果是链表则插入链表尾节点上(jdk1.7 是插入到链表头节点上)，插入完成后还判断链表的节点数是否大于等于设定好的链表转红黑树的阈值，如果满足则将链表转换为红黑树。

4：两个版本都会产生扩容操作，只不过 jdk1.8 中扩容涉及到对红黑树的操作以及优化了在 hash 冲突时计算元素新下标的代码，使其非常简单高效！


### 哈希算法
**哈希算法的定义**
哈希算法又称为摘要算法，它可以将任意数据通过一个函数转换成长度固定的数据串，这个映射转换的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。 可见，摘要算法就是通过摘要函数 f()对任意长度的数据 data 计算出固定长度的摘要 digest，目的是为了发现原始数据是否被人篡改过

摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算 f(data)很容易，但通过 digest 反推 data 却非常困难。而且，对原始数据做一个 bit 的修改，都会导致计算出的摘要完全不同。
那有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要呢？完全有可能！因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况就是我们说的碰撞。

**哈希函数的要求**
1. 将任何一条不论长短的信息，计算出唯一的一摘要(哈希值)与它相对应，对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同

2. 摘要的长度必须固定，散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小

3. 摘要不可能再被反向破译。也就是说，我们只能把原始的信息转化为摘要，而不可能将摘要反推回去得到原始信息，即哈希算法是单向的

**哈希函数 MD5**
```
这些要求都是比较理论的说法，我们那一种企业常用的哈希算法 MD5 来说明：现
使用 MD5 对三段数据分别进行哈希求值：
1.MD5('数据结构和算法') = 31ea1cbbe72095c3ed783574d73d921e
2.MD5('数据结构和算法很好学')=0fba5153bc8b7bd51b1de100d5b66b0a
3.MD5('数据结构和算法不好学')=85161186abb0bb20f1ca90edf3843c72


从其结果我们可以看出：MD5 的摘要值(哈希值)是固定长度的，是 16 进制的 32位即 128 Bit 位，无论要哈希的数据有多长，多短，哈希之后的数据长度是固定的，另外哈希值是随机的无规律的，无法根据哈希值反向推算文本信息，其次 2，3 表明尽管只有一字之差得到的结果也是千差万别，最后哈希的速度和效率是非常高的，这一点我们可能还体会不到，因为我们哈希的只是很短的一串数据，即便我们哈希的是整个这段文本，用 MD5 计算哈希值
```

