---
title: 20190924 高并发
---

## 大数据 ##

高并发 -> 日志* -> 分析行为 ->画像 ->推荐 -> 服务*

## TCP/IP 网络模型 ##

三次握手：确认客户端和服务端的收发正常（IO 正常），可以进行连接

- C -> S : 发送 sync 包给服务端，表示客户端想与服务端建立连接

- S -> C：服务端接收到客户端的 sync 包，并将 sync +ack  包，发送给客户端

  表示服务端接收到客户端的请求，并回复客户端可以与服务端建立连接

- C -> S: 客户端接收到服务端的 ack 包，将 ack 包发送给服务端，表示客户端马上与服务端建立连接，让服务端做好准备

四次离手：TCP 是稳定的连接，对于连接断开需要经过 Client 与 Server 双方都确认后，才可关闭

- C - >S: 发送 fin 包给服务端，表示客户端想与服务端断开连接
- S -> C: 发送 ack包给客户端，表示接收到服务端的断开请求
- S -> C: 发送 fin 包给客户端，表示服务端想与客户端断开连接
- 
- C -> S: 发送 ack 包给服务端，服务端接收到后，表示与客户端断开连接。

```shell
TCP/IP协议  OSI 7L参考模型
GET / www.baidu.com/
7:应用层www.baidu.com  IP:80  1212
http，smtp，ssh
4:传输层控制：【三次握手>>（传输数据）>>四次分手】
tcp，udp
SOCKET：IP:PORT-IP:PORT
netstat -natp
3:网络层： 192.168.9.11
ip，icmp
ROUTE：下一跳
route -n
2:链路层
以太网：Ethernet：MAC
ARP：全F，两点通信，交换机学习
arp -a
```



![](http://img.zwer.xyz/blog/20190924154314.png)

注意： 三次握手和四次离手中间不可拆分，一定针对于两台特定  IP:Port - IP:Port

```
netstat antp

route -n # -n 查看 IP 地址

arp -a  
0.0.0.0 默认网关
```

### 功能分层 ###

层与层依赖
1，能够申请到端口号
2，路由表有下一跳条目
3，ARP能请求到下一跳MAC
4，三次握手
5，传输数据
6，四次分手

![](http://img.zwer.xyz/blog/20190924202409.png)

### 下一跳 ###

```
整个互联网建立在下一跳的模式下
IP是逻辑上的两个端点
MAC是物理上连接的两个节点
端点间TCP传输过程中
确认机制
状态机制
不可分割
解析数据包需要成本
交换机：二层，只关心MAC地址
学习机制：
路由器：三层，只关心IP和路由表
LVS服务器：四层，只关心PORT，状态
nginx：七层，关心socket对应关系

## 负载均衡 ##
```



### 硬件 ###

```
昂贵，性能优越
F5 BIG-IP 
Citrix NetScaler
A10
```

### 软件 ###

> 便宜，灵活度（开源）

|      | 四层                                           | 七层                                     |
| ---- | ---------------------------------------------- | ---------------------------------------- |
|      | tcp 之上的第四层协议                           | LVS 只能操作IP,端口 ，在操作系统内核中。 |
|      | nginx<br/>haproxy<br/>httpd  “apache”webserver |                                          |

### LVS -DR ###

> Director 接收用户的请求，然后根据负载均衡算法选取一台 realserver，将包转发过去，最后由realserver直接回复给用户。

```
DR：Director
客户端发送对VIP的请求
lvs负载到后端某一台server
后端server处理后，直接封包回送客户端
源IP地址一定是lvs上面陪的那个公网服务地址
也就后端server要配置这个ip
后端server收到的数据包是lvs没有变动过的（IP：vip）
目标ip一定是自己持有的
so：多个server，接入互联网的server持有相同的IP，是不对的
必须将后端server中的vip隐藏起来（对外隐藏）

VIP: 虚拟服务器地址
DIP: 转发的网络地址
1，和RIP通信：ARP协议，获取Real Server的RIP：MAC地址
2，转发Client的数据包到RIP上（隐藏的VIP）
RIP: 后端真实主机(后端服务器)

CIP: 客户端IP地址
```

LVS 配置 

1. 配置 LVS 服务器的虚拟IP 和开启 IPv4 转发

   ```
   [root@node01 ~]# ifconfig eth0:0 192.168.170.100/24  # 临时生效
   echo “1” > /proc/sys/net/ipv4/ip_forward 
   ```

2. 修改 RP 服务器的文件

   ```shell
   echo 1 > /proc/sys/net/ipv4/conf/eth0/arp_ignore 
   echo 2 > /proc/sys/net/ipv4/conf/eth0/arp_announce 
   echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore 
   echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce 
   ```

3. 配置 RP 服务器的本地环回地址

   ```shell
   ifconfig lo:0 192.168.170.100 netmask 255.255.255.255
   ```

4. 在 RP 服务器上安装 httpd 服务

   ```
   yum install -y httpd
   ```

5. 设置 主页

   ```
   cd /var/www/html
   vi index.html
   内容： from 192.168.170.102
   ```

6. 启动 httpd 服务

   ```shell
   service httpd start
   ```

7. LVS 配置

   ```
    yum install ipvsadm -y
   ipvsadm -A -t 192.168.170.100:80 -s rr 
   ipvsadm -a -t 192.168.170.100:80 -r 192.168.170.102 -g
   ipvsadm -a -t 192.168.170.100:80 -r 192.168.170.103 -g
   
   ipvsadm -ln
   浏览器刷新: 访问vip
   ipvsadm –lnc
   netstat -natp
   ```

   

LVS 参考 https://superproxy.github.io/docs/lvs/index.html