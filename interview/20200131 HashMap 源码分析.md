---
title: 20200131 HashMap 源码分析
date: 2020-01-31
---

[TOC]

在 HashMap 源码之前，需要具备位运算、数据结构、数组、链表、红黑树的基础。

学习 HashMap 源码的目的：更深入学习 HashMap，学习 HashMap 的设计思想   

##  HashMap 集合介绍

HashMap 实现 Map 接口，用于存储 K,V 形式的键值对。

HashMap 的特点是线程不安全，查找速度快。

在 JDK 1.8 之前，采用数组+链表的数据结构。

在 JDK 1.8 之后，HashMap 采用数组+链表+红黑树的数据结构，增加红黑树的目的提供查询效率。

链表 => 红黑树的条件：

1. 链表的阈值大于等于 8 
2. 数组的长度大于等于 64 

注意：若数组长度小于 64，即使链表的阈值达到了 8，只会数组扩容，并不会链表转为红黑树

面试题：哈希表底层采用何种算法计算 hash 值？ 还有那些算法	可以计算 hash 值？

```
底层采用的 key 的 hashCode 方法的值结合数组长度进行无符号右移(>>>)、按位异或(^)、按位与(&)计算出索引。还可以采用： 取余数、伪随机数法eg: 10%8 = 2, 11%8=3 其他计算方式效率比较低，而位运算效率高。
```

## HashMap 底层数据结构

### HashMap 存储数据分析

![](http://img.zwer.xyz/blog/20200201093038.png)

### HashMap 面试题

1. 面试题1： HashMap 中的 hash 函数是怎么实现的？ 还有哪些 hash 函数的实现方式？ 

   ```
   对于 key 的 hashCode 做 hash 操作，无符号右移 16 位然后做异或运算。
   还有伪随机数法和取余数法。这 2 种效率都比较低。而无符号右移 16 位和异或运算效率是最高的。
   ```

2. 面试题2：当两个对象的 hashCode 相等时会怎么样？

   ```
   当两个对象的 hashcode 相等时，会产生哈希碰撞，若 key 值内容相同则替换旧的 value。不然连接到链表后面（JDK 1.8之后），链表长度超过阈值 8 并且数组长度大于等于 64 就转换为红黑树存储。
   ```

3. 面试题3： 何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞？

   ```
   只要两个元素的 key 计算的哈希码值相同就会发生哈希碰撞。 
   JDK8 前使用链表解决哈希碰撞。
   JDK8 之后使用链表+红黑树解决哈希碰撞。
   ```

4. 面试题4： 如果两个键的 hashCode 相同，如何存储键值对？

   ```
   hashCode 相同，通过 equals 方法比较内容是否相同。
   相同： 则新的 value 覆盖之前的 value 
   不相同： 则将新的键值对添加到哈希表中
   ```

5. 在不断的添加数据过程中，会设计扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的 2 倍，并将原有的数据复制过来。

6. 通过上述描述，当位于一个链表中的元素较多，即 hash 值 相同但是内容不相等且元素较多时，通过 key 值依次查找效率较低。而 JDK 1.8 中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阈值)超过 8 时且当前数组的长度 > 64 时，将链表转换为红黑树，这样大大减少了查找时间。JDK 8 在哈希表中引入红黑树的原因只是为了查找效率更高。

   简单的来说。哈希表是由数组+链表+红黑树（JDK 1.8 增加了红黑树部分）实现的。如下图所示。

   ![](http://img.zwer.xyz/blog/20200201095314.png)

   

## HashMap 的继承结构

```java
public abstract class AbstractMap<K,V> implements Map<K,V> {
    ...
}


public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
    ...
}
```

从上面的源码可以看出，HashMap 继承 AbstractMap 抽象类，而 AbstractMap 抽象类实现了 Map 接口，HashMap 也实现了 Map 接口。

## HashMap 集合类的成员变量

1. 集合的初始化容量(必须是二 n 的次幂)

   ```java
   static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
   ```
   
   问题：为什么必须是 2 的 n 次幂？ 如果输入值不是 2 的 n 次幂比如是 10 会怎么样？
   
   HashMap 构造方法还可以指定集合的初始化容量大小：
   
   ```java
   // 构造一个带指针初始容量和默认加载因子(0.75)的空 HashMap
   HashMap(int initalCapacity) 
   ```
   
   当向 HashMap 中添加一个元素的时候，需要根据 key 的 hash 值，去确定其在数组中的具体位置。**HashMap 为了存取高效，要尽量减少碰撞，就是要尽量把数据分配均匀**，每个链表长度大致相同，这个实现就在把数据存到那个链表中的算法。
   
   这个算法实际上就是**取模**，hash%length, 计算机中直接求余效率不如位运算。所以源码中做了优化，使用 hash&(length-1),而实际上 hash%length 等于 hash&(length-1)的前提是 length 是 2 的 n 次幂。
   
   ```java
      在 length 等于 2 的 n 次幂的前提下: hash%length = hash&(length-1)
   举例说明：
      hash=11,length=8
      
        0000 1011     11
      & 0000 0111     7
      -------------------
        0000 0011     3 
        
      hash=10,length=8
      
        0000 1010     11
      & 0000 0111     8
      -------------------
        0000 0010     2
          
   ```
   
      为什么这样均匀分布减少碰撞呢？ 2 的 n 次方实际是 1 后面 n 个 0， 2 的 n 次方 -1 实际就是 n 个 1；
   
2. threshold 阈值大小

   ```java
    this.threshold = tableSizeFor(initialCapacity);
    // 注意： tableSizeFor 方法返回的值会赋给 threshold
   ```

3. 集合的最大容量

   集合的容量上限为 2^30 

   ```java
   static final int MAXIMUM_CAPACITY = 1 << 30;
   ```

4. 当链表的值超过 8 则会转红黑树(JDK 1.8 新增)

   当桶(bucket)上的结点大于这个值时会转为红黑树

   ```java
   static final int TREEIFY_THRESHOLD = 8;
   ```

   问题：**为什么 Map 桶中的节点个数超过 8 才转为红黑树？**

   ```java
   8 这个阈值定义在 HashMap 中，针对这个成员变量，在源码的注释中只说明了 8 是 bin(bin 就是 bucket(桶)) 从链表转成树的阈值，但是并没有说明为什么是 8：
   在 HashMap中有一段注释：
   Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (http://en.wikipedia.org/wiki/Poisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) /factorial(k)). The first values are:
         0:    0.60653066
         1:    0.30326533
         2:    0.07581633
         3:    0.01263606
         4:    0.00157952
         5:    0.00015795
         6:    0.00001316
         7:    0.00000094
         8:    0.00000006
         more: less than 1 in ten million
   
   翻译: 因为树节点的大小大约是普通节点的两倍，所以我们只在箱子(bucket)里有足够的节点可以使用的时候才使用树节点(参见TREEIFY THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机hashCodes下，bin中节点的频率遵循泊松分布(http:en.wikipedia.orgwikiPoisson分布)，默认调整阈值为0.75，平均参数约为0.5，尽管由于resiz而存在较大的方差
   ```

5. 当链表的值小于 6 则会从红黑树转回链表

   ```java
     static final int UNTREEIFY_THRESHOLD = 6;
   ```

6. 当 Map 里面的数量超过这个值时，表中的桶才能进行树形化，否则桶内元素太多时会扩容，而不是树形化为了避免进行扩容、树形化选择的冲突，这个值不能小于 4* TREEIFY_THRESHOLD(8)

   ```java
    static final int MIN_TREEIFY_CAPACITY = 64;
   ```

7. **table 用来初始化(必须是二的 n 次幂)**

   ```java
      transient Node<K,V>[] table;
   ```

   table 在 JDK 1.8 中我们了解到 HashMap 是由数组+链表+红黑树来组成的结构其中 table 就是 HashMap  中的数组， jdk8 之前数组类型是 Entry<K,V> 类型。从 JDK 1.8 之后是 Node<K,V> 类型。只是换了个名字，都实现了一样的接口： Map.Entry<K,V> 。负责存储键值对数据。

8. **HashMap 中存放元素的个数(重点)**

   ```java
   // 存放元素的个数，注意这个不等于数组的长度    
   transient int size;
   ```

   size 为 HashMap 中 K-V 的实时数量，不是数组 table 的长度。

9. 用来记录 HashMap 的修改次数

   ```java
   // 每次扩容和更改 map 结构的计数器
   transient int modCount;
   ```

10. 用来调整大小下一个容量的值计算方式为(容量*负载因子)

   ```java
   // 临界值 当实际大小(容量*负载因子) 超过临界值时，会进行扩容
   int threshold;
   ```

11. 哈希表的加载因子(重点)

    ```java
    // 加载因子
     final float loadFactor;
    ```

    说明：

    1. loadFactor 加载因子， 是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为：size/capacity ,而不是占用桶的数量去除以 capacity。 capacity 是桶的数量，也就是 table 的长度

       loadFactor 太大导致查找元素效率低，大小导致数组的利用率，存放的数据会很分散。loadFactor 的默认值为 0.75 是官方给出一个比较好的临界值

       当 HashMap 里面容纳的元素已经达到 HashMap 数组长度的 75% 时，表示 HashMap 太挤了，需要扩容，而扩容这个过程设计 rehash、复制数据等操作，非常消耗性能。所以开发中尽量减少扩容的次数，可以通过创建同时在 HashMap 的构造器中可以定制 loadFactor

       ```java
       构造方法：
       public HashMap(int initialCapacity, float loadFactor) 
       // 构造一个带指定初始容量和加载因子的空 HashMap。
       ```

    2. 为什么负载因子设置为 0.75，初始化临界值时 12？

       ``` 
       例如:
       加载因子是 0.4。 那么 16*0.4 --> 6 如果数组中满个空间就扩容会造成数组利用率太低了。
       加载因子是 0.9.  那么 16*0.9 --> 14 那么这样就会导致链表有点多了。导致查找元素效率低。
       
       所以既兼顾数组利用率又考虑链表不要太多，经过大量测试 0.75 是最佳方案
       ```

       - threshold 计算公式： capacity(数组长度默认为 16) * loadFactor(负载因子默认 0.75)。这个值是当前已占用数组长度的最大值。当 Size >= threshold 的时候，那么就要考虑对数组的 resize(扩容)， 也就说，这个意思就是**衡量数组是否需要扩增的一个标椎。**扩容后的 HashMap 容量是之前容量的两倍。

## HashMap 构造方法

```java
    public HashMap() { // 无参构造方法
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
	// 带参构造方法，给定初始化数组容量
	public HashMap(int initialCapacity) { 
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }
	// 带参构造方法，给定初始化数组容量和定制负载因子
	public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }

    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

### tableSizeFor 方法分析

tableSizeFor 方法的作用将 cap 的值转换为 2 的 n 次幂值

```java
 int n = cap - 1; 
 n |= n >>> 1;
 n |= n >>> 2;
 n |= n >>> 4;
 n |= n >>> 8;
 n |= n >>> 16;

// 假设 cap = 10 
int n = 9
    
               0000 0000 0000 1001
n |= n >>> 1;  0000 0000 0000 0100   
----------------------------------------    
               0000 0000 0000 1101   13
n |= n >>> 2;  0000 0000 0000 0011   
----------------------------------------    
               0000 0000 0000 1111   15  
n |= n >>> 4;  0000 0000 0000 0000 
-----------------------------------------   
               0000 0000 0000 1111 
    
```

问题1： 为什么 cap 要减 -1 ？

```
因为 cap 的值可能正好是 2 的 n 次幂，当 cap的值 正好等于2的 n 的次幂时，通过无符号右移和按位或，会将 cap 的值变为原来的 2 倍。

int n = 8 (8 是 2 的 3  次方幂)
              0000 1000
n |= n >>> 1; 0000 0100
------------------------------
              0000 1100  
n |= n >>> 2; 0000 0011 
------------------------------
              0000 1111   15           
```

问题2： 为什么 n 无符号右移(>>>) 最高是 16，而不是 32

```java
MAXIMUM_CAPACITY = 1 << 30 = 1 * 2^30 
```

## HashMap 源码 put 方法分析

```java
    public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

### hash 方法分析

> 计算 key 的哈希值

```java
	static final int hash(Object key) {
        int h;
        // 将 h 进行无符号右移，然后跟 key 的哈希值做按位异或运算
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }

	// 再通过 putVal 方法中 i = (n - 1) & hash， 计算数组下标的位置 i  
	
```

### resize 扩容方法分析*

> resize 用于 HashMap 数组扩容和第一次创建数组
HashMap  扩容思想:

在 JDK 1.8 中，1. rehash   2. 创建新的数组，遍历数组将旧数组中数据移动到新数组来。

在 JDK 1.8 中，当数组扩容时，不在采用 rehash 的方式，而是采用判断 hash 值2的最高位，若 hash  值最高位为 0，则在原数组的位置，若 hash 值最高位为 1，则在 原数组的位置+原数组的容量 oldCap。

HashMap 扩容：

HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 （n-1）& hash 的结果相比，只是多了一个 bit 位，所以节点要么就在原来的位置，要么就被分配到“**原位置+旧容量**”这个位置。

怎么理解呢？ 例如我们从 16 扩展到 32 时，具体的变化如下所示：

**&（按位与运算）:运算规则：相同的二进制数位上，都是 1 的时候，结果为 1 ，否则为零**

```
n: 16   0000 0000 0000 0000 0000 0000 0001 0000
n: 15   0000 0000 0000 0000 0000 0000 0000 1111
假设 hashCode 生成的值：
(n-1) & hash
hash1(key1): 1111 1111 1111 1111 0000 1111 0000 0101
hash2(key2): 1111 1111 1111 1111 0000 1111 0001 0101
------------------------------------------------------
             0000 0000 0000 0000 0000 0000 0000 0101  5 表示计算出来的索引是 5
扩容：16*2 ==> 32
n: 32   0000 0000 0000 0000 0000 0000 0010 0000
n-1:31  0000 0000 0000 0000 0000 0000 0001 1111
假设 hashcode 生成的值：
(n-1) & hash
hash1: 1111 1111 1111 1111 0000 1111 0000 0101
hash2: 1111 1111 1111 1111 0000 1111 0001 0101  相较于 hash1 高位多出 1 bit 位
----------------------------------------------------
       0000 0000 0000 0000 0000 0000 0000 0101  31 &  hash1 = 5
       0000 0000 0000 0000 0000 0000 0001 0101  31 &  hash2 = 16+5 = 21
```

<img src="http://img.zwer.xyz/blog/20200202215223.png"  />

正是因为这样巧妙的 rehash 方式，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1 bit 是 0 还是 1 可以认为是随机的，在 resize 的过程中保证了 rehash 之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了 rehash 之后不会出现更严重的 hash 冲突，均匀的把之前的冲突的节点分散到新的桶中了。

resize 方法源码：


```java
	final Node<K,V>[] resize() {
         // 第一次调用 put 方法，table 初始化为 null
        Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        // 调用 HashMap 无参构造方法，默认 threshold 初始化为 0
        int oldThr = threshold; 
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // 扩容： 数组的容量扩大为原来的 2 倍  newCap = oldCap * 2 
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                     oldCap >= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr << 1; // double threshold 
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY; // 16
            // newThr = 16 * 0.75 
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) { 
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }
        // 将 newThr 值赋给成员变量 threshold
        threshold = newThr; 
        @SuppressWarnings({"rawtypes","unchecked"})
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; // 创建新的数组
        table = newTab;
        if (oldTab != null) { // 将旧的数组复制到新数组中
            for (int j = 0; j < oldCap; ++j) {
                Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)  // 桶中只有一个元素
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof TreeNode) // 判断是否是红黑树
                        // 说明是红黑树来处理冲突的，则调用相关方法把树分开
                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else { // preserve order  采用链表处理冲突
                        Node<K,V> loHead = null, loTail = null;
                        Node<K,V> hiHead = null, hiTail = null;
                        Node<K,V> next;
                        do {
                            next = e.next;
                            if ((e.hash & oldCap) == 0) { // 原位置
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else { // 原位置+原数组容量
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            loTail.next = null;
                            newTab[j] = loHead; // 原数组位置
                        }
                        if (hiTail != null) {
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead; // 原数组位置+原数组容量
                        }
                    }
                }
            }
        }
        return newTab;
    }
```



### putVal 方法分析

```java
	 // 向 Map 中存储 K,V 
	 final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
         // 数组不存在，则 resize 方法创建数组，resize 返回一个新的数组
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        //  (n-1)&hash = hash%n (注意： n 必须是 2 的 n次方幂) ，计算数组下标位置 i
        //  若数组下标 i 的位置没有数据，则将新节点放入
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            // 若两个 key 哈希值相同并且内容相同，则将原来的位置的数据替换
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p; 
            else if (p instanceof TreeNode) // 判断是否为树节点
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else { // 链表
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) { // 循环遍历到链表的末尾，增加新节点  
                        p.next = newNode(hash, key, value, null);
                        // TREEIFY_THRESHOLD = 8 ,当链表长度大于 8 时，链表 => 红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
       // 循环遍历链表过程中，若发现两个 key 哈希值相同并且内容相同，则将原来的位置的数据替换
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
            // 若出现两个的 key 哈希值相同且内容相同，将旧的值返回，同时替换为新的值
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ++modCount;
        if (++size > threshold)
            resize(); // 扩容
        afterNodeInsertion(evict);
        return null;
    }
```

### treeifyBin 方法分析

> 当链表的长度大于 8 且数组的长度大于 64 ，则将链表转为红黑树。
>
> 当链表的长度大于 8，但数组的长度小于 64，则进行数组扩容 

```java
    final void treeifyBin(Node<K,V>[] tab, int hash) {
        int n, index; Node<K,V> e;
        // 当链表的长度大于 8，但数组的长度小于 64，则进行数组扩容 
        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
            resize(); // 扩容
        // 将链表转为红黑树
        else if ((e = tab[index = (n - 1) & hash]) != null) {
            TreeNode<K,V> hd = null, tl = null;
            do {
                TreeNode<K,V> p = replacementTreeNode(e, null);
                if (tl == null)
                    hd = p;
                else {
                    p.prev = tl;
                    tl.next = p;
                }
                tl = p;
            } while ((e = e.next) != null); // 遍历链表中的所有元素
            if ((tab[index] = hd) != null) // 将 hd 放入数组下标为 index 的位置
                hd.treeify(tab); // 树转为红黑树
        }
    }
```

总结：

1. 根据哈希表中元素个数确定是扩容还是树形化。

2. 如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系

   然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容。

## 如何设计多个非重复的键值对要存储 HashMap 的初始化？

### HashMap 的初始化问题描述

如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化 HashMap 的时候就应该制定它的容量，以防止 HashMap 自动扩容，影响使用效率。

默认情况下 HashMap 的容量是 16，但是，如果用户通过构造方法指定了一个数字作为容量，那么 Hash 会选择大于该数字的第一个 2 的幂作为容量。(3->4]、7->8,9->16)。

《阿里巴巴 Java 开发手册》中建议我们设置 HashMap 的初始化容量。

![](http://img.zwer.xyz/blog/20200202220749.png)

当然，以上建议也是有理论支撑的。HashMap 的扩容机制，就是当达到扩容条件会进行扩容。

HashMap 的扩容条件就是当 HashMap 中的元素个数（size）超过临界值（threshold）时就会自动扩容。在 HashMap 中，threshold = loadFactor * capacity 。

所以，如果我们没有设置初始容量大小，随着元素的不断增加， HashMap 会有可能发生多次扩容，而 HashMap 中的扩容机制决定了每次扩容都需要重建 Hash 表，是非常影响性能的。

但是设置初始化容量，设置的是数值不同也会影响性能，那么当我们已知 HashMap 中即将存放的 KV 个数的时候，容量设置成多少为好？

### HashMap 中容量的初始化

下面摘自于阿里巴巴 Java 开发手册： 

![](http://img.zwer.xyz/blog/20200202220133.png)

## 红黑树简介

1. 每个节点是黑的或者红的
2. 根节点是黑色的
3. 如果一个节点是红的，则它的两个儿子都是黑的
4. 对于每个叶子节点，从该节点到根节点的所有路径上包含相同数目的黑节点。

测试：向红黑树存储的数据：

```java
20 31 10 13 23 5 51 8 9 28 25
```

[点击红黑树测试](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)

## 参考资料

[HashMap 源码分析-视频](https://www.bilibili.com/video/av83630901?p=10)

[数据结构可视化](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)



