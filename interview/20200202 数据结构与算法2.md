---
title:  20200202 数据结构与算法2
date: 2020-02-02
---


## 

[TOC]

## 树

### 树的定义

树在维基百科中的定义为：，**树**（英语：Tree）是一种无向图（undirected graph），其中任意两个顶点间存在唯一一条路径。或者说，只要没有回路的连通图就是树。在计算机科学中，**树**（英语：tree）是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点都只有有限个子节点或无子节点
- 没有父节点的节点称为根节点

- 每一个非根节点有且只有一个父节点

- 除了根节点外，每个子节点可以分为多个不相交的子树

- 树里面没有环路(cycle)

![](http://img.zwer.xyz/blog/20200111171949.png)



### 高度、深度、层

节点的高度：节点到叶子节点的最长路径(边数)，所有叶子节点的高度为 0。

节点的深度：根节点到这个节点所经历的边的个数，根的深度为 0。

节点的层数：节点的深度+1

树的高度：根节点的高度

![](http://img.zwer.xyz/blog/image-20200111172600818.png)



### 二叉树

（1）**二叉树的定义**

二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是**左子节点**和**右子节点**。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点，如下图所示均是二叉树

![image-20200111173954258](D:\photo\TyporaPicture\image-20200111173954258.png)

当然了在这三棵树中，有两棵比较特殊的二叉树，分别是 T2 和 T3

T2：叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作**满二叉树**。

T3：叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作**完全二叉树**。

满二叉树我们特别容易理解，完全二叉树我们可能就不是特别能够分清楚，下面我画几棵树，你分析一下看哪些是完全二叉树

![](http://img.zwer.xyz/blog/20200111210218.png)

为什么完全二叉树的叶子节点都靠左排列呢？

由上图分析可知，完全二叉树节点存储在数组中的利用率比非完全二叉树存储在数组中的利用率高

而完全二叉树结构是数组存储形式反推过来的，使用完全二叉树在数组存储能最有效率的利用空间。

（2）**二叉树存储**

- 链式存储：存储空间离散的，也就是不连续的

  ![](http://img.zwer.xyz/blog/20200111211240.png)



- 顺序存储：需要开辟一块连续的内存空间存储数据

  ![](http://img.zwer.xyz/blog/20200111211642.png)

  总结一下，如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。

  所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。

（3）**二叉树查找树**

​		**二叉查找树支持动态数据的快速插入，删除，查找操作**。

​		若任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值

​		若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值

​		任意节点的左、右子也分别为二叉查找树

​		没有键值相等的节点

![](http://img.zwer.xyz/blog/20200111212410.png)

二叉树查找树实现

- 二叉树结构

  ```java
  /**
   * 二叉查找树节点
  */
  private static class Node {
      private Node left; // 左节点
      private int data; // 存储数据
      private Node right; // 右节点
  
      public Node(Node left, int data, Node right) {
          this.left = left;
          this.right = right;
          this.data = data;
      }
  
      public Node getLeft() {
          return left;
      }
  
      public void setLeft(Node left) {
          this.left = left;
      }
  
      public int getData() {
          return data;
      }
  
      public void setData(int data) {
          this.data = data;
      }
  
      public Node getRight() {
          return right;
      }
  
      public void setRight(Node right) {
          this.right = right;
      }
  
      @Override
      public String toString() {
          return "Node{" +
              "left=" + left +
              ", data=" + data +
              ", right=" + right +
              '}';
      }
  }
  
  ```

- 添加节点

  ```java
  /**
       * 向二叉查找树中放 value
       *
       * @param value 待放入二叉树中的 value 值
       * @return boolean true if insert success else false
       */
      public boolean putValue(int value) {
          if (parent == null) {
              parent = createNode(value);
              return true;
          }
  
          Node p = parent; // 临存父节点
          while (p != null) {
              if (p.data > value) {
                  if (p.left == null) {
                      p.left = createNode(value);
                      return true;
                  }
                  p = p.left;
              } else if (p.data < value) {
                  if (p.right == null) {
                      p.right = createNode(value);
                      return true;
                  }
                  p = p.right;
              } else {
                  return false;
              }
          }
          return false;
      }
  
  
  ```

- 中序遍历

  ```java
    /**
       * 中序遍历： 左中右
     * @return
       */
      public void findAll(Node root){
          // TODO: 2020/1/12  中序遍历
          // 先递归打印左子树，再打印根节点，最后递归打印右子树
          if(root == null) return;
          if(root.left != null){
              findAll(root.left);
          }
          System.out.print(root.data+"\t");
          if(root.right != null){
              findAll(root.right);
          }
  
      }
  
  ```

- 查找节点

  ![](http://img.zwer.xyz/blog/20200112095455.png)

  

  ```java
  /**
   * 在二叉查找树查找指定的值
   *
   * @param value 待查找的值
   * @return Node  if find it return object else null
  */
  public Node findValue(int value) {
      Node p; // 临时存放父节点
      // 如果根节点等于 null，则直接返回
      if ((p = parent) == null) return null;
  
      while (p != null) {
          if (p.data > value) {
              p = p.left;
          } else if (p.data < value) {
              p = p.right;
          } else {
              return p;
          }
      }
      return null;
  }
  
  ```

- 删除节点

  1. 删除节点是叶子节点
  2. 删除节点只有一个子节点
  3. 删除节点有两个子节点

  ![](http://img.zwer.xyz/blog/20200112093709.png)

  

  ```java
      /**
       * 删除指定的节点
       * 分为 3 种情况：
       * 1. 该节点是叶子节点
       * 2. 该节点有一个子节点
       * 3. 该节点有二个子节点
       *
       * @param value 待删除节点的值
       * @return true | false  return true if find and remove success else false
       */
      public boolean removeValue(int value) {
          // 记录当前节点
          Node p;
          if ((p = parent) == null) return false;
          // 记录当前节点的父节点
          Node p_parent = null;
          // 1. 找到要删除指定 value 对应节点的位置
          while (p != null) {
              if (p.data > value) {
                  p_parent = p;
                  p = p.left;
              } else if (p.data < value) {
                  p_parent = p;
                  p = p.right;
              }else {
                  break;
              }
          }
  
          // 2. 如果要删除的节点有两个子节点,需要找到要删除的节点右子树下左节点的最小值
          Node rightTree = p.right;
          Node p_rightTree = p;
          if (p.left != null && p.right != null) {
              while(rightTree.left != null){
                  p_rightTree = rightTree;
                  rightTree = rightTree.left;
              }
              // 将要删除的节点的 value 值更新
              p.data = rightTree.data;
              p = rightTree;
              p_parent = p_rightTree;
          }
  
          Node child = null;
          // 3. 如果要删除的节点下有一个子节点或者没有子节点
          if(p.left != null){
              child = p.left;
          }else if(p.right != null){
              child = p.right;
          }else{
              child = null;
          }
  
          // 4. 正式删除节点信息
          if (p_parent == null) {// 要删除节点是根节点
              parent = child;
              return true;
          }else if(p_parent.left == p){ //更新父节点的左节点
              p_parent.left = child;
              return true;
          }else{ // 更新父节点的右节点
              p_parent.right = child;
              return true;
          }
      }
  
  ```

- 二叉查找树的最大值/最小值

  ```java
      /**
       * 查找二叉树中的最大值（在右子树上或者根节点）
       * @return Node is in the binaryTree maximum
       */
      public Node findMaximumValue(){
          Node p;
          if((p=parent) == null) return null;
          while(p.right != null) {
              p = p.right;
          }
          return p;
      }
  
      /**
       * 查找二叉树查找树的最小值(在左子树上或者根节点)
       * @return Node is in the binaryTree minimum
       */
      public Node findMinimumValue(){
          Node p;
          if((p=parent) == null) return null;
          while(p.left != null){
              p = p.left;
          }
          return p;
      }
  
  
  ```

- 查找某个节点的前驱节点和后继节点

  **后继节点：该节点右子树中最小的节点**， **前驱节点：该节点左子树中最大的节点**

  ```java
      /**
       *  后继节点：该节点右子树中最小的节点
       *  前驱节点：该节点左子树中最大的节点
       *   查找某个节点的前驱节点
       * @param value
       * @return
       */
      public Node findPrevNodeByValue(int value){
          Node node = findValue(value);
          Node lTree;
          if(node != null && (lTree=node.left) != null){
              while(lTree.right != null){
                  lTree = lTree.right;
              }
              return lTree;
          }
          return null;
      }
  
      /**
       * 后继节点：该节点右子树中最小的节点
       * 前驱节点：该节点左子树中最大的节点
       * 查找某个节点的后驱节点
       * @param value
       * @return Node
       */
      public Node findNextNodeByValue(int value){
          Node node = findValue(value);
          Node rTree;
          if(node != null && (rTree=node.right) != null){
              while(rTree.left != null){
                  rTree = rTree.left;
              }
              return rTree;
          }
          return null;
      }
  
  ```

(4) **二叉查找树的时间复杂度**

**如果中序遍历二叉查找树，能够得到一个有序的数据序列，时间复杂度是 O(n)，非常的高效，因此二叉查找树也叫二叉排序树**，

```
在实际的软件开发中我们一般都是存储的包含很多属性的对象，判断的时候利用对象中的某一个属性进行判断，
对象中的其他属性我们称为卫星数据，对于有重复数据的二叉查找树，我们应该如
何存储和查找呢？有两种方案：
1：二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。

2：每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理，当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除

```

![](D:\photo\TyporaPicture\20200112150041.png)

对于图中第一种情况属于最坏的情况，二叉查找树已经退化成了链表，左右子树极度不平衡，此时查找的时间复杂度肯定是 O(n)。对于图中第二种或者第三种情况是属于一个比较理想的情况，我们代码的实现逻辑以及图中所示表明插入，查找，删除的时间复杂度其实和树的高度成正比，那也就是说时间复杂度为 O(height)

那如何求一棵完全二叉树的高度？即求一棵包含 n 个节点的完全二叉树的高度？
对于一棵满二叉树而言：树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从上图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(k-1)。

但是对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(k-1)个之间（我们假设最大层数是 k）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：
1+2+4+8+...+2^(k-2) +1 =<n <= 1+2+4+8+...+2^(k-2) +2^(k-1)

这是一个等比数列，根据等比数列求和公式 S= a1(1-q^(n-1))/ 1-q，其中 q 是公比，n 为数据个数。
所以：我们利用求和公式对上述式子进行计算后得知，k 的一个最大值是：$log_2n+1$
也就是说完全二叉树的高度小于等于：$log_2n$
通过我们的分析我们发现一棵极度不平衡的二叉查找树，它的查找性能和单链表一样。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这种特殊的二叉查找树也可以叫做平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。

### 平衡二叉树 AVL 

（1）**平衡二叉树的定义**

**平衡二叉查找树**：简称平衡二叉树。由前苏联的数学家 **A**delse-**V**elskil 和 **L**andis 在1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：

1. 可以是空树。

2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。

![](http://img.zwer.xyz/blog/20200112161354.png)

上图中的两棵树，左边的是 AVL 树，它的任何节点的两个子树的高度差别都<=1；而右边的不是 AVL 树，因为 7 的两颗子树的高度相差为 2(以 2 为根节点的树的高度是 2，而以 8 为根节点的树的高度是 0)。

**对于给定结点数为** **n** **的** **AVL** **树，最大高度为** **O(log2n).**也就说，从 n 个数中，查找一个特定值时，最多需要 log2n 次。因此，AVL 是一种特别适合进行查找操作的树。

（2）**失衡的四种情况及调整方法**

在平衡二叉树中，当我们插入新的元素时，为了保证二叉搜索树的特性，很容易导致某些结点失衡，即该结点的平衡因子大于 1。而在二叉树中，任意结点孩子最多只有左右两个，而且导致失去平衡的必要条件就是当前结点的两颗子树的高度差等于 2。因此，致使一个结点失衡的插入操作有以下 4 中。

-  在结点的左子树的左子树插入元素,LL 插入；
-  在结点的左子树的右子树插入元素,LR 插入；
-  在结点的右子树的左子树插入元素,RL 插入；
-  在结点的右子树的右子树插入元素,RR 插入。

![](http://img.zwer.xyz/blog/20200113214326.png)

```java
/**
 * @Auther:zwer
 * @Date:2020/1/12 22:00
 * @Description:com.szxy.tree
 * @Version:1.0
 **/
public class AvlTree<T extends Comparable> {

    // 定义二叉平衡树的根节点
    private AvlNode tree;

    /**
     * 获取某个节点的高度
     * @param node 节点
     * @return height is tree of node
     */
    private int getAvlNodeHeight(AvlNode node){
        return node == null ? 0 : node.height;
    }

    /**
     * 获取根节点的高度
     * @return height is tree of node
     */
    public int getTreeNodeHeight(){
        return getAvlNodeHeight(tree);
    }

    /**
     * 计算两个之间的高度差
     * @param h1  height of node1
     * @param h2  height of node2
     * @return int  height difference
     */
    public int getHeightDiff(int h1, int h2){
        return -(h2 - h1);
    }

    /**
     * 中序遍历
     * @param node is the AvlTree of  node
     */
    public void inOrderTree(AvlNode node){
        if (node == null) return;
        inOrderTree(node.left);
        System.out.print(node.data+"-->");
        inOrderTree(node.right);
    }

    @Override
    public String toString() {
        inOrderTree(tree); // 中序遍历显示 Avl Tree
        return "";
    }

    /**
     * 左左旋转： 当前的节点的左子树上左子树节点
     * @param node current node that is unbalance 失衡节点
     * @return AvlNode 失衡后重新调整的节点
     */
    public AvlNode ll(AvlNode node){
        // 保存失衡节点的左子树
        AvlNode left_node_tree = node.left;
        // 将失衡节点的左子树上的右子树挂在失衡节点的左子树上
        node.left = left_node_tree.right;
        // 将失衡节点的左子树的左子树作为原来的失衡节点
        left_node_tree.right = node;
        // 重新计算高度节点之间高度差
        node.height = getHeightDiff(getAvlNodeHeight(node.left),getAvlNodeHeight(node.right))+1;
        left_node_tree.height = getHeightDiff(getAvlNodeHeight(left_node_tree.left),getAvlNodeHeight(left_node_tree.right))+1;
        return left_node_tree;
    }


    /**
     * 右右旋转
     * @param node  AvlNode 失衡节点
     * @return
     */
    public AvlNode rr(AvlNode node){
        AvlNode new_root = node.right;
        node.right = new_root.left;
        new_root.left = node;
        node.height = getHeightDiff(getAvlNodeHeight(node.left), getAvlNodeHeight(node.right));
        new_root.height = getHeightDiff(getAvlNodeHeight(new_root.left), getAvlNodeHeight(new_root.right));
        return new_root;
    }

    /**LR: RR -- LL
     * 左右旋转： 当前的节点的左子树上右子树节点
     * @param node 失衡节点
     * @return AvlNode 失衡后重新调整的节点
     */
    public AvlNode lr(AvlNode node){
        // RR
        node.left = rr(node.left);
        // LL
        AvlNode avlNode = ll(node);
        return avlNode;
    }

    /**
     * RL: LL -- RR
     * @param node
     * @return
     */
    public AvlNode rl(AvlNode node){
        // LL
        node.right = ll(node.right);
        // RR
        AvlNode avlNode = rr(node);
        return avlNode;
    }

    /**
     * 添加新节点
     * @param data 节点数据
     */
    public void addAvlNode(T data){
       this.tree =  this.addAvlNode(tree,data);
    }

    /**
     * 添加 AvlNode
     * @param node
     * @return
     */
    public AvlNode addAvlNode(AvlNode node, T data){
        if(node == null){
             node =  new AvlNode<T>(data);
        }else{
            int compared = data.compareTo(node.getData());
            if(compared > 0){ // 向右子树上插入
                node.right = addAvlNode(node.right, data);
                // 计算高度差
                if(getAvlNodeHeight(node.right) - getAvlNodeHeight(node.left) == 2){
                    if(data.compareTo(node.right.data) > 0){
                        node = rr(node);
                    }else{
                        node = rl(node);
                    }
                }
            }else{ // 向左子树上插入
                node.left = addAvlNode(node.left, data);
                // 计算高度差
                if (getAvlNodeHeight(node.left) - getAvlNodeHeight(node.right) >=2){
                    if(data.compareTo(node.left.data) > 0){
                        node = lr(node);
                    }else{
                        node = ll(node);
                    }
                }
            }
            // 重新计算 node  高度
        }
        node.height = getAvlNodeHeight(node);
        return node;
    }

    /**
     * 插入测试
     * @param args
     */
    public static void main(String[] args) {
        AvlTree tree = new AvlTree();
        tree.addAvlNode(10);
        tree.addAvlNode(8);
        tree.addAvlNode(3);
        tree.addAvlNode(12);
        tree.addAvlNode(9);
        tree.addAvlNode(4);
        tree.addAvlNode(5);
        tree.addAvlNode(7);
        tree.addAvlNode(1);
        tree.addAvlNode(11);
        tree.addAvlNode(17);
        // 打印结果
        System.out.println(tree);
    }

    /**
     *     二叉平衡树节点
     */
    private static class AvlNode<T extends  Comparable> {
        // 存储节点数据
        private T data;
        // 左节点
        private AvlNode left;
        // 右节点
        private AvlNode right;
        // 节点高度
        private int height;

        public AvlNode(AvlNode left, T data, AvlNode right, int height) {
            this.left = left;
            this.data = data;
            this.right = right;
            this.height = height;
        }

        public AvlNode(AvlNode left, T data, AvlNode right) {
            this(left, data, right, 0);
        }

        public AvlNode(T data) {
            this(null, data, null);
        }

        public T getData() {
            return data;
        }

        public void setData(T data) {
            this.data = data;
        }

        public AvlNode getLeft() {
            return left;
        }

        public void setLeft(AvlNode left) {
            this.left = left;
        }

        public AvlNode getRight() {
            return right;
        }

        public void setRight(AvlNode right) {
            this.right = right;
        }

        public int getHeight() {
            return height;
        }

        public void setHeight(int height) {
            this.height = height;
        }
    }
}

```



## 堆

>  堆是一种树，一种特殊的树

### 堆的定义

1. 堆是一种完全二叉树
2. 堆中任意一个结点的值大于等于（或者小于等于）其子树中每个节点的值

解释：

堆是一个完全二叉树，对于完全二叉树除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列，

当然想到完全二叉树我们立马能能够想到我们之前所讲到的，**完全二叉树可以用数组来进行存储**，之前的树每个节

点不仅要存储数据还要存储左右节点的指针，虽然比较符合我们的认知但毕竟消耗一些存储空间，但是完全二叉树

就不一样了，比较适合用数组来存储，是非常节省存储空间的，单纯的通过数组的下标我们就可以找到一个节点的

左子节点和右子节点。

### 堆的分类

- 大顶堆

  对于堆中的任意一个结点的值大于等于其子树结点的值。

  ![](http://img.zwer.xyz/blog/20200116192547.png)

- 小顶堆

  对于堆中的任意一个结点的值小于等于其子树结点的值

![](http://img.zwer.xyz/blog/20200116192602.png)

### 堆的结构

堆是一种完全二叉树，可以用数组存储堆中结点的值

数组中下标为 k 的节点的左子节点，就是下标为 2*k 的节点，右子节点就是下标为 2 * k +1 的节点，父节点就是

下标为 k/2 的节点，其中 k>=1。另外我们也发现，数组下标为 0 的位置并未存储数据，这是因为为了方便于在程

序中计算，所以会浪费掉数组的一个存储空间。

![](http://img.zwer.xyz/blog/20200116194812.png)

### 堆的实现

- 创建堆

  ```java
  /**
   * @Author:zwer
   * @Date:2020/1/16 20:37
   * @Description:com.szxy.heap
   * @Version:1.0
   * 堆的定义+堆的操作
   **/
  public class HeapDemo {
      // 定义一个 int 类型的数组，用于存储堆中结点的值
      private int[] data;
      // size 表示该数组的最大容量
      private int size;
      // count 表示该数组存在的元素的个数
      private int count;
      
      /**
       * 给定数组的容量大小，初始化数组
       * @param capacity 数组容量大小
       */
      public HeapDemo(int capacity){
          this.data = new int[capacity+1]; // 堆采用数组存储，默认下标为 0 的位置不存储数据
          this.size = capacity;
          this.count = 0;
      }
  
      @Override
      public String toString() {
          return "HeapDemo{" +
                  "data=" + Arrays.toString(data) +
                  ", size=" + size +
                  ", count=" + count +
                  '}';
      }   
  }   
  
  ```

- 添加元素到堆中

  堆是一种树，完全二叉树，采用数组存储数据。当向堆中添加新结点时，则向数组的末尾添加数据，而新增的数据的可能会堆的结构，需要对数组中数据进行位置调换，这个过程叫做堆化。

  ```java
      /**
       * 向堆中插入数据
       * 采用自底向上的方式
       * 插入数据 => 堆化 => 对数组中元素进行位置交换
       * @param value 新添加的值
       */
      public void insert(int value){
          if(count >= size) return;  // 堆空间已满不能再添加
          this.data[++count] = value;
          // 堆化： 自下而上的方式
          heapIfFromBottom2Top(this.data,count);
      }
  
      /**
       * 堆化： 数据交换
       * @param data    原数组
       * @param end     数组中存储元素的末尾位置
       */
      public void heapIfFromBottom2Top(int[] data, int end){
          int i = end;
          while(i/2 > 0 && (this.data[i] > this.data[i/2])){
              swap(data,i, i/2);
              i /= 2; // 等价于 i = i/2
          }
      }
  
      /**
       * 交换数组下标 i 和 j 对应的值
       * @param data 数组
       * @param i 数组下标
       * @param j 数组下标
       */
      private void swap(int[] data, int i, int j){
          int temp = data[i];
          data[i] = data[j];
          data[j] = temp;
      }
  
  ```

- 删除堆顶元素

  第一种删除方式：将堆顶的元素直接删除，通过堆顶元素的子节点替换堆顶元素的位置。这种方式的弊端是删除堆顶素后新产生的堆，可能不符合完全二叉树的定义。（不采用这种方式删除）

  第二种删除方式：将数组末尾的元素直接替换堆顶元素，然后进行堆化操作。

  ![](http://img.zwer.xyz/blog/image-20200116210523278.png)

  实现代码如下：

  ```java
      /**
       * 删除堆顶元素
       * @return
       */
      public int removeMaxTop(){
          int max = data[1]; // 默认数组下标为 1 作为堆顶（最大值）
          // 1. 将最后一个元素直接放在堆顶,并减少数量
          data[1] = data[count--];
          // 2. 堆化让其继续成为一个合格的堆---->这个时候要自上而下堆化
          heapIfFromTop2Bottom(data,1,count);
          return max;
      }
  
  ```

### 堆的应用

- 堆排序

  1. 建堆：将传入的数组进行堆化操作（从非叶子节点 n/2 处开始）
  2. 排序：利用堆的特性（这里以大顶堆为例，堆顶的值最大），每次循环时，将堆顶节点的值与堆末尾节点的值交换，紧接着做堆化操作，注意去掉堆末尾节点进行堆化操作

  ```java
  /**
   * @Author:zwer
   * @Date:2020/1/18 10:43
   * @Description:com.szxy.heap
   * @Version:1.0
   * 堆排序：
   * 1. 建堆：将传入的数组进行堆化操作（从非叶子节点 n/2 处开始）
   * 2. 排序：利用堆的特性（这里以大顶堆为例，堆顶的值最大），
   *         每次循环时，将堆顶节点的值与堆末尾节点的值交换，
   *         紧接着做堆化操作，注意去掉堆末尾节点进行堆化操作
   **/
  public class HeapSortTest01 {
  
      /**
       * 建堆操作
       * @param arr 数组
       * @param n   数组的长度 - 1
       */
      private void buildHeap(int[] arr, int n){
          for(int i = n/2; i > 0; i--){
              heapFromTop2Bottom(arr,i,n);
          }
      }
  
      /**
       * 排序：
       * 1. 将堆顶元素与堆末尾元素进行数据交换
       * 2. 将堆的大小减一，并进行堆化操作
       * 3. 循环步骤 1,2，直到数组中元素排序完成
       * @param arr 数组
       * @param n 数组的长度 - 1
       */
      private void sort(int[] arr, int n){
          while( n > 1){
              swap(arr,1,n);
              heapFromTop2Bottom(arr,1,--n);
          }
      }
  
      /**
       * 堆排序
       */
      public void heapSort(int[] arr){
          buildHeap(arr, arr.length - 1);
          // System.out.println("heap:"+ Arrays.toString(arr));
          sort(arr, arr.length - 1);
      }
  
      /**
       * 堆化（从顶向下）
       * @param arr
       * @param begin
       * @param end
       */
      private void heapFromTop2Bottom(int[] arr, int begin, int end){
          int maxPos;
          while(true){
              maxPos = begin;
              if( 2 * begin <= end && arr[2 * begin] > arr[maxPos]){
                  maxPos = 2 * begin;
              }
              if( 2 * begin + 1 <= end && arr[2 * begin + 1] > arr[maxPos]){
                  maxPos = 2 * begin + 1;
              }
              if(begin == maxPos)  break;
              swap(arr, begin, maxPos);
              begin = maxPos;
          }
      }
  
      /**
       * 交换两个数组下标对应的值
       * @param arr
       * @param i
       * @param j
       */
      private void swap(int[] arr,int i, int j){
          int temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
      }
  
      /**
       * 测试
       * @param args
       */
      public static void main(String[] args) {
          HeapSortTest01 heap = new HeapSortTest01();
          int[] arr = new int[8];
          arr[1] = 10;
          arr[2] = 5;
          arr[3] = 3;
          arr[4] = 12;
          arr[5] = 15;
          arr[6] = 7;
          arr[7] = 0;
          System.out.println(Arrays.toString(arr));
          heap.heapSort(arr);
          System.out.println(Arrays.toString(arr));
      }
  }
  
  ```

  堆排序总结：堆排序是稳定的排序算法，建堆的时间复杂度为 $O(N)$， 排序的时间复杂度为  $O(N * log N)
  $，堆排序总体的时间复杂度为 $O(N*logN)$ 。

  

## 图

### 图的定义

![](http://img.zwer.xyz/blog/20200118162336.png)

图：由顶点及其对应的边组成的

边：连接两个顶点之间的一条线

度：其他顶点到一个顶点相连接的边的条数。

- 出度：从一个顶点出发到其他任意顶点边的个数
- 入度：从其他任意顶点出发到一个顶点边的个数

![](http://img.zwer.xyz/blog/20200118163409.png)

以上图中 A 顶点为例， A 顶点的出度为 2，A  顶点的入度为 1 。

### 图的分类

- 无向图

  QQ 好友之间的关系可以用无向图表示，一个顶点表示一位 QQ 用户，则这个顶点边的个数就表示该 QQ 用户好友的个数。

  ![](http://img.zwer.xyz/blog/20200118162336.png)

- 有向图

  微博中的博主与粉丝的关系可以用有向图表示，一个顶点表示一位微博用户，以微博用户 A 举例，微博用户 A   顶点的出度为 2，由下图可知微博用户 A  关注了微博用户 B 、C 。微博用户 A 顶点的入度为 1，由下图可知微博用户 A 的粉丝有微博用户 D 。

  ![](http://img.zwer.xyz/blog/20200118163409.png)

- 带权图

  在带权图中，每条边都有一个**权重（weight）**，我们可以通过这个权重来表示 QQ 好友间的亲密度

![](http://img.zwer.xyz/blog/20200118170424.png)

### 图的存储

- 邻接矩阵存储图

  邻接矩阵存储图底层依赖一个二维数组，对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j] 和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。

  ![](http://img.zwer.xyz/blog/20200118172018.png)

  邻接矩阵应用场景：适用比较密集的图，否则使用邻接矩阵法比较浪费空间

- 邻接表存储图

  邻接表（Adjaceny List）。下面以一幅图来描述邻接表存储图

  ![](http://img.zwer.xyz/blog/20200118173221.png)

  这里采用数组存储顶点，链表存储顶点边之间的关系

### 图的应用

> 使用邻接表实现无向图，采用数组下标的值作为对应顶点的值，数组中存储的为 `LinkedList` 链表类型，用于存储顶点间边的关系。最后提供了广度优先搜索算法`【DFS】`和深度优先搜索算法`【BFS】`

- 构造无向图

  > 构造方法中对所有顶点 `point` 和 `LinkedList` 数组进行初始化，并提供添加顶点的方法 `add` 和打印搜索目标顶点的路径方法 `print` 

  ```java
  /**
   * @Author:zwer
   * @Date:2020/1/18 17:46
   * @Description:com.szxy.graph
   * @Version:1.0
   * 采用【邻接表法】存储无向图
   **/
  public class UnGraph {
  
      /**
       *  points 表示无向图中顶点的个数
       */
      private Integer points;
  
      /**
       * 邻接表，默认使用数组下标作为对应顶点的值
       */
      private LinkedList<Integer> adjacencyList[];
  
      /**
       * 初始化
       * 采用数组下标的值对应顶点的值
       * @param points
       */
      public UnGraph(Integer points) {
          // 指定顶点数
          this.points = points;
          // 初始化数组
          this.adjacencyList = new LinkedList[this.points];
          // 初始化数组中每个槽位
          for(int i = 0; i <points; i++){
              this.adjacencyList[i] = new LinkedList<Integer>();
          }
      }
  
      /**
       * 向无向图中
       * @param s 顶点 s
       * @param t 顶点 t
       */
      public void  add(int s, int t){
          this.adjacencyList[s].add(t);
          this.adjacencyList[t].add(s);
      }
  
      /**
       * 打印查找路径
       * @param prev   访问 target 顶点路线数组
       * @param source 源顶点
       * @param target 目标顶点
       */
      public void print(int[] prev, int source, int target){
          if(prev[target] != -1 && source != target){
              // 递归到 source == target 结束，从 source 顶点开始打印路线
              print(prev, source ,prev[target]);
          }
          System.out.print(target+"->");
      }
  
      @Override
      public String toString() {
          return "UnGraph{" +
                  "points=" + points +
                  ", adjacencyList=" + Arrays.toString(adjacencyList) +
                  '}';
      }
  }
  
  ```

- 广度优先搜索算法实现

  > 从源顶点 source 开始，地毯式搜索目标顶点 target，直到找到目标顶点停止，最后打印搜索路径

  ```java
   /**
       * 【广度优先搜索算法】实现
       * @param source 起始顶点
       * @param target 目标顶点
       */
      public void bfs(int source,int target){
          if(source == target) return;
          // 记录已经访问过的顶点
          boolean[] visited = new boolean[this.points];
          // 存放未访问过的顶点队列（将要访问的顶点队列）
          Queue<Integer> queue = new LinkedList<Integer>();
          queue.add(source);
          // 记录顶点 source -> 顶点 target 的路径
          int[] prev = new int[this.points];
          // 初始化记录  -1
          for(int i = 0; i < prev.length; i++){
              prev[i] = -1;
          }
          // 循环遍历【地毯式搜索】
          while(!queue.isEmpty()){
              // 从队列中取出顶点，找到该顶点的相邻顶点
              Integer poll = queue.poll();
              // 标记已经被访问过的顶点
              visited[poll] = true;
              // 遍历该顶点的相邻顶点
              for( int i = 0; i < this.adjacencyList[poll].size(); i++){
                  // poll 顶点相邻的顶点
                  Integer p_edge = this.adjacencyList[poll].get(i);
                  if(! visited[p_edge]){
                      // 记录路径
                      prev[p_edge] = poll;
                      if(p_edge == target){
                          // 打印搜索路径
                          print(prev,source, target);
                          return;
                      }
                      queue.add(p_edge);
                  }
              }
          }
      }
  
  ```

- 深度优先搜索算法实现

  > 从源顶点 source 开始搜索，搜索到相邻顶点，若没有找到目标顶点 ，则返回继续搜索其他顶点，直到找到目标顶点

  ```java
      /**
       * 【深度优先搜索算法】实现
       * @param source 源顶点
       * @param target 目标顶点
       */
      public void dfs(int source,int target){
          // 若源顶点的值与目标顶点的值相同则直接返回
          if(source == target) return;
          // 创建 boolean 类型的数组用于存放已访问过的顶点
          boolean[] visited = new boolean[this.points];
          // 创建 int 类型的数组用于存放寻找目标顶点经历的路线，初始化值全为 -1
          int[] prev = new int[this.points];
          for (int i = 0; i < prev.length; i++) {
              prev[i] = -1; // 初始化的值为 -1，表示顶点未被访问过
          }
          // 递归调用 returnDFS 方法
          returnDFS(source,target,visited,prev);
          // 打印路线
          print(prev, source, target);
      }
  
      /**
       * 用于深度优先搜索算法中 returnDFS 方法
       * 判断是否找到目标顶点，若找到，则递归结束
       * 默认初始值为 false
       */
      private boolean found;
  
      /**
       * 回溯思想，实现使用递归
       * 访问一个顶点及相邻的顶点，若没有目标顶点，则返回。
       * 更换路线，继续寻找，直到找到目标顶点
       * @param point 起始顶点
       * @param target 目标顶点
       * @param visited 已访问过的数组
       * @param prev 存放路线的数组
       */
      public void returnDFS(int point, int target, boolean[] visited, int[] prev){
          // 若找到目标顶点则结束递归
          if(found) return;
          // 标记顶点 point 已经被访问过
          visited[point] = true;
          // 若顶点 point 的值等于目的顶点的值
          if(point == target) {
              found = true;
              return;
          }
          //  遍历目标顶点的相邻顶点
          for(int i = 0; i < this.adjacencyList[point].size(); i++){
              // 目标顶点的相邻顶点
              Integer p_connect = this.adjacencyList[point].get(i);
              if(!visited[p_connect]){
                  // 标记顶点 p_connect 顶点经过顶点 p
                  prev[p_connect] = point;
                  /*
                  // 我自己写的
                  if(p_connect == target){
                      found  = true;
                      return;
                  }
                  */
                  // 递归调用 returnDFS
                  returnDFS(p_connect,target, visited, prev);
              }
          }
      }
  ```

- 测试

  ```java
    /**
       * 邻接表法测试
       * @param args
       */
      public static void main(String[] args) {
          //  构建一个无向图的对象
          UnGraph unGraph = new UnGraph(8);
          unGraph.add(0,1); // 顶点 0 -> 顶点 1
          unGraph.add(0,3);
          unGraph.add(1,2);
          unGraph.add(1,4);
          unGraph.add(2,5);
          unGraph.add(3,4);
          unGraph.add(4,5);
          unGraph.add(4,6);
          unGraph.add(5,7);
          unGraph.add(6,7);
          System.out.println("无向图: "+unGraph);
          int source = 0;
          int target = 7;
          // 测试广度优先搜索算法 0->3->4->5->7->
          System.out.print("广度优先搜索: ");
          unGraph.bfs(source, target);
          // 测试深度优先搜索算法 0->1->2->5->4->6->7->
          System.out.print("\n深度优先搜索: ");
          unGraph.dfs(source, target);
      }
  ```

## 字符串匹配/查找

### BF算法 

> BF 算法即暴风算法，英文全称为 Brute Force。从字面意思可知该字符串匹配的规则简单、粗暴，直接用主串依次匹配子串，若匹配失败，则从主串中匹配失败的下一位置重新开始匹配,直到匹配成功后停止，或者主串被子串全部比较完毕停止。

```java
/**
 * @Author:zwer
 * @Date:2020/1/27 22:25
 * @Description:com.szxy.string
 * @Version:1.0
 * 字符串匹配算法之暴风（朴素）匹配算法
 **/
public class BruteForce {

    /**
     * 暴风算法
     * 模式匹配：使用 pattern 模式串匹配 target 主串中的字串
     * @param target  主串
     * @param pattern 模式串
     */
    public int bruteForce(String target, String pattern){
        // 合法性校验
        if(target == null || target.length() == 0 ||
                pattern == null || pattern.length() == 0) return -1;
        // 将字符串转为字符串数组，便于操作
        char[] t_array = target.toCharArray();
        char[] p_array = pattern.toCharArray();
        // 调用 match 方法
        return match(t_array,p_array);
    }

    /**
     * 模式匹配
     * @param t_array  主串字节数组
     * @param p_array  模式串字节数组
     * @retrun position 能匹配上则返回 p_array 在 t_array 中匹配的下标,匹配不上则返回-1
     */
    private int match(char[] t_array, char[] p_array){
        int i = 0; // 定义主串的字节数组下标
        int j = 0; // 定义模式串字节数组下标
        int position = -1; //若匹配成功后，主串字节数组中对应的开头的位置
        // 循环遍历使用 p_array 模式串尝试匹配 t_array 主串
        while(i < t_array.length && j < p_array.length){
            if(t_array[i] == p_array[j]){// 依次用子串中每个字节匹配主串中的指定的字节
                i++;  
                j++;  
            }else{
                i = i-j+1; // 从匹配失败的位置+1重新开始匹配
                j = 0;
            }
        }
        // 计算匹配成功后 position 的值
        if(j == p_array.length){
            position = i-j;
        }
        /*
        if(i <= t_array.length) position = i - p_array.length;
        else position = -1;
        */
        // 返回 position
        return position;
    }

    /**
     * 暴风算法实现2  采用双重 for 循环的方式
     * @param t_array  目标串
     * @param p_array  模式串
     * @return int if match success return position else return -1
     */
    private int bruteForce(char[] t_array, char[] p_array){
        // 合法性校验
        if(t_array == null || t_array.length == 0 ||
                p_array == null || p_array.length == 0 || p_array.length > t_array.length){
            return -1;
        }
        // 暴风算法比较最多的次数为（主串的长度-子串的长度+1）
        for(int i=0; i < t_array.length - p_array.length+1; i++){
            boolean isFlag = true;
            for(int j = 0; j < p_array.length; j++){
                if(t_array[i+j] != p_array[j]){
                    isFlag = false;
                    break;
                }
            }
            if(isFlag)
                return i;
            else
                continue;
        }
        return -1;
    }

    public static void main(String[] args) {
        BruteForce bf = new BruteForce();
        String target = "abbccde";
        String pattern = "bc";
        int position = bf.bruteForce(target.toCharArray(), pattern.toCharArray());
        System.out.println(position);
    }
}


```

### RK 算法

> RK 算法是对 BF 算法的改进升级，采用了 hash 函数的方式对字符串进行比较，若遇到 hash 碰撞（即匹配到两个字符串 hash 值相同），再采用字节数组的方式按个比较，若字节数组全部比较成功，则返回对应主串中匹配成功字串的起始位置。
>
> 通过 hash 函数的方式比较字符串的方式，相较与 BF 算法降低了时间复杂度，提高字符串匹配的效率。

```java
/**
 * @Author:zwer
 * @Date:2020/1/28 17:09
 * @Description:com.szxy.string
 * @Version:1.0
 * RK 算法也就是 hash 算法
 **/
public class RabinKarp {

    /**
     * 基于 hash 函数
     * @param str 取 hash 函数字符串
     * @param R 进制数 10/8/2/26
     * @param K 将字符串映射到 K 的范围内 0-k-1
     * @param start 字符串开始的位置
     * @param len 字符串的长度
     * @return int hashValue
     */
    private int hash(String str, int R, int K, int start, int len){
        int hash = 0;
        for(int i=start; i < start+len; i++){
            hash = (hash*R+str.charAt(i))%K;
        }
        return hash%K;
    }

    /**
     * 若 hash 值相同，即发生了 hash 碰撞，再采用字符按个比较
     * @param t  目标串/主串
     * @param p  模式串/子串
     * @param i  主串上比较字符的位置
     * @return
     */
    private boolean match(String t, String p, int i){
        for(int j=0; j < p.length(); j++){
            if(t.charAt(i+j) != p.charAt(j)){
                return false;
            }
        }
        return true;
    }

    /**
     * rk 算法
     * @param target 目标串/主串
     * @param pattern 模式串/子串
     * @return int position or -1
     */
    public int rk(String target, String pattern){
        // 合法性校验
        if(target == null || target.length() == 0 || pattern == null ||
                pattern.length() ==0 || pattern.length() > target.length())  return -1;
        // 计算模式串的 hash 长度
        int phash = hash(pattern, 26, 31, 0, pattern.length());
        // bruteForce 需要字符串比较的次数
        int count = target.length() - pattern.length() + 1;
        for(int i=0; i < count; i++){
            if(hash(target,26,31,i, pattern.length()) == phash && match(target,pattern,i)){
                return i;
            }
        }
        return -1;
    }

    /**
     * 测试
     * @param args
     */
    public static void main(String[] args) {
        RabinKarp rk = new RabinKarp();
        String target = "abcd";
        String pattern = "c";
        int result = rk.rk(target, pattern);
        System.out.println(result);
    }
}

```



## 算法思想

> 这里主要介绍几种常见的算法思想，如贪心思想、分治思想、回溯思想、动态规划等以及介绍新的数据结构 B+ 树，虽然我们平时可能用不到 B+ 树这种数据结构，但是我们平时用的一些框架和软件中包含了  B+ 树这种数据结构，因此我们需要理解 B+ 树数据结构。

### 贪心思想之贪心算法

> **贪心算法**（英语：greedy algorithm），又称**贪婪算法**，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。 比如在旅行推销员问题中，如果旅行员每次都选择最近的城市，那这就是一种**贪心算法**。 贪心算法在有最优子结构的问题中尤为有效

贪心思想是指在解决问题的过程中，将大问题拆解为一个个小问题，解决每个小问题时每次选择都是最好（或者说

最优）的方式，直到所有小问题都已经被解决，最后将的小问题的解决结果综合起来就是大问题的解决结果。

适用贪心算法的前提：局部最优策略可导致全局最优解。

### 分治思想

> 分治算法在维基百科上的定义为：在计算机科学中，**分治法**是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

分治思想的核心思想是: **分而治之**

分治思想与递归的区别：**分治算法是一种处理问题的思想，递归是一种编程技巧**

分治思想的运用： 归并排序、快速排序

- 归并排序的实现

  ```java
  /**
   * @Author:zwer
   * @Date:2020/1/28 22:52
   * @Description:com.szxy.divideAndconquer
   * @Version:1.0
   * 分治思想的体现之归并排序
   **/
  public class MergeSortDemo {
  
      /**
       * 归并排序
       * @param arr 待排序的数组
       * @return arr
       */
      public int[] mergeSort(int[] arr){
          if(arr == null || arr.length < 2) return arr;
          int mid = arr.length/2;
          int[] left = Arrays.copyOfRange(arr, 0, mid);
          int[] right = Arrays.copyOfRange(arr, mid, arr.length);
          return merge(mergeSort(left), mergeSort(right));
      }
  
      /**
       * 合并两个有序数组
       * @param left   有序数组1
       * @param right   有序数组2
       * @return arr
       */
      private int[] merge(int[] left,int[] right){
          int[] arr = new int[left.length+right.length];
          int l = 0; // left 数组的下标
          int r = 0; // right 数组的下标
          for(int i=0; i < arr.length; i++){
              if(l >= left.length){
                  arr[i] = right[r++];
              }else if(r >= right.length){
                  arr[i] = left[l++];
              }else if(left[l] < right[r]){
                  arr[i] = left[l++];
              }else if(left[l] > right[r]){
                  arr[i] = right[r++];
              }
          }
          return arr;
      }
  
      /**
       * 测试
       * @param args
       */
      public static void main(String[] args) {
          MergeSortDemo ms = new MergeSortDemo();
          int[] arr = {2,1,4,8,5,0};
          int[] result_arr = ms.mergeSort(arr);
          System.out.println(Arrays.toString(result_arr));
      }
  
  }
  
  
  ```

### 回溯思想

> 回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
>
> 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走

- 回溯思想之八皇后问题

  ```java
  /**
   * @Author:zwer
   * @Date:2020/1/29 21:06
   * @Description:com.szxy.divideAndconquer
   * @Version:1.0
   * 回溯思想的运用之八皇后问题
   * 八皇后问题，也可以延伸为 n 皇后问题
   * 八皇后问题
   * 在 8 * 8 正方形棋盘上随机放置 8 个皇后，并需要满足以下条件：
   * 1. 任意两个皇后不能在同一个行上
   * 2. 任意两个皇后不能在同一个列上
   * 3. 任意两个皇后不能在一个对角线上
   **/
  public class Queen {
  
      /**
       *  数组的下标表示第 i 个皇后，也表示第 i 个皇后在第 i 行
       *  数组的下标表示皇后所在的行的位置
       *  数组中每个值表示皇后所在的列的位置
       */
      private int[] queen;
  
      /**
       * n 皇后问题，包括 8 皇后问题
       * @param queenNum 皇后数，也指棋盘的大小
       */
      public void backMethod(int queenNum){
          // 确定皇后数组的大小
          queen = new int[queenNum];
          // 皇后数组初始化
          for(int i=0; i < queen.length; i++){
              queen[i] = -1;
          }
          // 从第 1 个皇后开始，对应的皇后数组下标是第 0 个
          int k = 0;
          while(true){
              // 水平移动皇后的位置
              queen[k] += 1;
              // 若皇后的位置超过棋盘的空间
              if(queen[k] >= queenNum){
                  // 若不是第一个皇后，则采用回溯思想，将当前皇后的位置恢复到初始状态，并回到上一个皇后的位置，重新开始
                  if(k > 0){
                      queen[k] = -1; //恢复初始位置
                      k--; // 回到上一行中皇后的位置
                      continue;
                  }else{//若第一个皇后的位置都超过棋盘的空间，则表示整个棋盘中所有的情况都已经遍历完毕，直接结束即可
                      break;
                  }
              }
              // 若皇后的位置不冲突
              if(!isMatch(k)){
                  k++;
                  if(k >= queenNum){
                      for (int i=0; i<queen.length;i++){
                          System.out.print(queen[i]+" ");
                      }
                      System.out.println();
                      /**********************************************/
                      k--; //k 溢出，将 k 回溯到最后一行继续搜索其他可能性
                      /**********************************************/
                  }
              }
          }
      }
  
      /**
       * 判断放置第 k 个皇后之后是否与之前的皇后冲突，
       * 判定冲突的条件是第 k 个皇后的于前面的第 i 个皇后在横轴坐标相等，
       * 或者横坐标和纵坐标之差相等（两者连线于横轴夹角为 45 度）如果冲突返回 true，否则返回 false
       * @param k 第 k 个皇后
       * @return
       */
      public boolean isMatch(int k){
          for(int i=k-1; i > -1; i--){
              if(queen[k] == queen[i] ||
                      Math.abs(k-i) == Math.abs(queen[k]-queen[i]))
                  return true;
          }
          return false;
      }
  
      /**
       * 测试
       * @param args
       */
      public static void main(String[] args) {
          new Queen().backMethod(8);
      }
  }
  
  ```

### 动态规划

> **动态规划（英语：*Dynamic programming**，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

那动态规划算法要表达的核心思想到底是什么？我们来看一个例子

```
A : "2+2+2+2+2=? 请问这个等式的值是多少? "
B : "计算 ing 。。。。。。结果为 10 "
A : "那如果在等式左边写上 1+ ，此时等式的值为多少? "
B : "quickly 结果为 11 "
A : "你怎么这么快就知道答案了"
A : "只要在 10 的基础上加 1 就行了 "
A : "所以你不用重新计算因为你记住了第一个等式的值为 10 ,动态规划算法也可以说是
'记住求过的解来节省时间'

```

由上可知：动态规划算法的核心就是记住已经解决过的子问题的解；而记住求解的方式有两种：

①自顶向下的备忘录法 ②自底向上。

下面举一个简单的例子-斐波那契数列

```java
/**
 * @Author:zwer
 * @Date:2020/1/29 23:16
 * @Description:com.szxy.divideAndconquer
 * @Version:1.0
 * 斐波那契数列
 * 第一项和第二项的值都为1：f(1) = f(2) = 1
 * 从第三项开始每项的值都等于前两项值之和：f(n) = f(n-1) + f(n-2)
 **/
public class FibonacciSequence {

    /**
     * 求第 n 项的斐波那契数列的值
     * @param n
     * @return
     */
    public static int fibonacci(int n){
        if(n <= 1) return 1;
        if(n == 2) return 1;
        // 递归调用 fibonacci
        return fibonacci(n-1)+fibonacci(n-2);
    }

    /**
     * 动态规划之自顶向下
     * @param n 斐波那契数列中第 n 项
     * @return
     */
    public static int fibonacciFromTop2Bottom(int n){
        // 数据不合法
        if(n <= 0) return -1;
        // 备忘录创建并初始化,注意：数组下标的 0 号位置不使用
        int[] memory = new int[n+1];
        for (int i = 0; i < n+1; i++) {
            memory[i] = -1;
        }
        return fibonacci(n,memory);
    }

    /**
     * 动态规划之自下而上
     * @return
     */
    public static int fibonacciPlusFromBottom2Top(int n){
        // 数据不合法
        if(n <= 0) return -1;
        // 备忘录创建并初始化,注意：数组下标的 0 号位置不使用
        int[] memory = new int[n+1];
        memory[1] = 1;
        memory[2] = 1;
        for(int i=3; i < n+1;i++){
            memory[i] = memory[i-1] + memory[i-2];
        }
        return memory[n];
    }

    /**
     * 动态规划之自下而上【优化】
     * 取消了备忘录数组，改为变量间赋值操作【变量思想】
     * @param n 斐波那契数列第 n 项
     * @return
     */
    public static int fibonacciPlusMaxFromBottom2Top(int n){
        if(n<=0) return -1;
        int memory_i_1 = 1;
        int memory_i_2 = 1;
        int memory_i = 0;
        // 这里运用了变量思想
        for(int i=2;i<n;i++){
            memory_i = memory_i_1 + memory_i_2;
            memory_i_1 = memory_i_2;
            memory_i_2 = memory_i;
        }
        return memory_i;
    }

    /**
     * 采用动态规划之自顶向下
     * @param n 斐波那契数列中第 n 项
     * @param memory int 类型的数组---备忘录，注意：int 类型数组下标 0 位置不使用
     * @return 斐波那契数列中第 n 项的值
     */
    private static int fibonacci(int n, int[] memory){
        // 若备忘录中存在，则直接返回
        if(memory[n] != -1) return memory[n];
        // 若备忘录中值不存在，第一次需要计算然后放入备忘录中
        if(n <= 2){
            memory[n] = 1;
        }else{
            memory[n] = fibonacci(n-1,memory) + fibonacci(n-2,memory);
        }
        return memory[n];
    }

    /**
     * 测试
     * @param args
     */
    public static void main(String[] args) {
        int testValue  = 45;
        /*****  普通递归方式  *****/
        long start = System.currentTimeMillis();
        int result = fibonacci(testValue);
        System.out.println(result+" speed time："+(System.currentTimeMillis()-start));
        /***** 动态规划之自顶向下 ****/
        long start2 = System.currentTimeMillis();
        int result2 = fibonacciFromTop2Bottom(testValue);
        System.out.println(result2+" speed time: "+(System.currentTimeMillis()-start2));
        /***** 动态规划之自下而上 ****/
        long start3 = System.currentTimeMillis();
        int result3 = fibonacciPlusFromBottom2Top(testValue);
        System.out.println(result3+" speed time: "+(System.currentTimeMillis()-start3));
        /***** 动态规划之自下而上【优化】 ****/
        long start4 = System.currentTimeMillis();
        int result4 = fibonacciPlusMaxFromBottom2Top(testValue);
        System.out.println(result4+" speed time: "+(System.currentTimeMillis()-start4));
    }

}


```

下面再举一个例子，切钢管问题

![](http://img.zwer.xyz/blog/20200130200431.png)



```java
/**
 * @Author:zwer
 * @Date:2020/1/30 11:04
 * @Description:com.szxy.divideAndconquer
 * @Version:1.0
 * 切钢管问题
 **/
public class CutSteelBar {

    /**
     * 切钢管问题求解
     * @param p 钢管长度与钢管价格对应表
     * @param n 钢管长度
     * @return 切割长度为 n 钢管的最大收益， n 钢管可能不切割时，收益最大
     */
    public static int cut(int[] p,int n){
        // 若钢管长度等于 0，则直接返回
        if(n==0) return 0;
        int q = Integer.MIN_VALUE;
        for(int i = 1; i <=n; i++){
            q = Math.max(q, p[i-1] + cut(p, n-i));
        }
        return q;
    }

    /**
     * 基于的动态规划之备忘录实现
     * @param n 钢管的长度
     * @return
     */
    public static int cutByDemo(int n, int[] p){
        if(n<=0) return 0;
        // 创建并初始化备忘录
        int[] remember = new int[n+1];
        for(int i = 1; i < n+1; i++){
            remember[i] = -1;
        }
        return  cut(remember, n, p);
    }

    /**
     *
     * @param remember 备忘录
     * @param n 长度为 n 的钢管
     * @param p 钢管长度与钢管价格表
     * @return int
     */
    public static int cut(int[] remember, int n, int[] p){
        // 若备忘录中已存在
        if(remember[n] >= 0) return remember[n];
        int q = -1;
        if(n == 0) q = 0;
        else {
            for(int i=1; i<=n; i++){
                q = Math.max(q, p[i-1]+cut(remember,n-i,p));
            }
        }
        remember[n] = q;
        return q;
    }

    /**
     * 切钢管问题
     * 动态规划之自下而上
     * @param p 钢管价格与钢管长度之间价格表
     * @return
     */
    public static int cutFromBottom2Top(int n, int[] p){
        // 数据合法性校验
        if(n <=0) return 0;
        // 创建并初始化备忘录
        int[] remember = new int[n+1];
        // 计算长度1-n之间的钢管切割利润的最大值
        for(int i=1; i < n+1; i++){
            int q = -1;
            for(int j=1; j<=i; j++)
                q = Math.max(q, p[j-1]+remember[i-j]);
            remember[i] = q;
        }
        return remember[n];
    }

    /**
     * 测试
     * @param args
     */
    public static void main(String[] args) {
        int[] p = {1,5,8,9,10,17,17,20,24,30};
        // 基于递归
        int result = cut(p, 4);
        System.out.println(result);
        // 基于动态规划之备忘录
        int result2 = cutByDemo(4, p);
        System.out.println(result2);
        // 基于动态规划之自下而上
        int result3 = cutFromBottom2Top(4, p);
        System.out.println(result3);
    }
}


```

- 动态规划的应用场景

  1：具有最优子结构性质的问题：指的是问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子

  问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型

  上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来

  2：无后效性：无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响，也就是说某状态以后的过程不会影响以前的状态，只与当前状态有关。

  ：具有重叠子问题的问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）；通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

  动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。不过，它也是出了名的难学。它的主要学习难点跟递归类似，那就是，求解问题的过程不太符合人类常规的思维方式。

- 动态规划中经典案例模型

  *（**1**）、线性模型*

  线性模型的是动态规划中最常用的模型，上面的钢条切割问题就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。我们以一个面试题为例进行说明

  面试题：在一个夜黑风高的晚上，有 n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i 号小朋友过桥的时间为 T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少？

  *（**2**）、区间模型：*

  区间模型的状态表示一般为 di，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。

  面试题 给定一个长度为 n（n <= 1000）的字符串 A，求插入最少多少个字符使得它变成一个回文串。

  *（**3**）、背包模型*

  背包问题是动态规划中一个最典型的问题之一，例如：对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？

[动态规划参考](https://blog.csdn.net/u013309870/article/details/75193592)

