---
title: 2018 MyBatis 框架
date: 2018-12-28 20:00
categories: ['数据库']
tags: ['Mybatis 框架']
---



# 1 框架的基本概念和配置文件

a）框架是程序员将代码进行封装，之后进行重复使用的过程

b) 框架其实一个半成品，连接数据库为例，需要添加驱动，用户，密码的信息

c）所以在使用之前告诉框架一个信息，通过以<u>配置文件</u>的方法告知，一般来说，

多数会使用 xml 作为框架的配置

d）因此，在使用框架开发代码时，需要编写好配置文件，代码的编写反而会减少。

e）框架都是第三方提供的，提供的都是 **Jar 包** 

​     使用框架前，必须将框架涉及的 jar 导入项目中。

f）常见的 Java 开发的框架

- MyBatis， ORM 框架， 底层是对 jdbc 进行了封装
- Spring， 是一个容器，管理东西
- SpringMVC，分层开发的框架
- Struts2，类似于 SpringMVC
- Hibernate，类似于 MyBatis

h）框架整合

​	SSM  = Spring + SpringMVC + MyBatis

​	SSH =   Spring + Struts + Hibernate





# 2  MyBatis 简介

> a） MyBatis 是一个 ORM 框架，用于操作数据库，底层是对 JDBC 进行的封装
>
> b） MyBatis 的前生 iBatis，是 Apache 下的一个项目，现在被迁移到了 GitHub 上
>



# 3 MyBatis 环境配置

## 3.1  创建项目 

​	java project 项目

## 3.2 导入 jar 包

### 3.2.1 MyBatis 核心包

mybatis-3.2.7.jar

### 3.2.2  MyBatis 依赖的 jar 包

asm-3.3.1.jar 字节码解析包，被 cglib 依赖
cglib-2.2.2.jar 动态代码实现
commons-logging-1.1.1.jar  日志包
javassist-3.17.1-GA.jar  字节码解析包 
log4j-1.2.17.jar              日志
log4j-api-2.0-rc1.jar      日志
log4j-core-2.0-rc1.jar    日志
slf4j-api-1.7.5.jar           日志
slf4j-log4j12-1.7.5.jar   日志 



### 3.2.3  驱动包 jar

mysql-connector-java-5.1.30.jar   

## 3.3 编写配置文件

a） 是一个 xml 文件，命名无要求(除中文)，位置无要求,一般

命名为 mybatis.xml 或者 mybatis-cfg.xml，**放在 src 目录下 .**

b） mybatis 配置文件的约束 dtd 约束 

- dtd 文件（ MyBatis 官方提供了 dtd 约束, 方便 xml 的编写 ）

```xml-dtd
<!DOCTYPE configuration
 PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-config.dtd"
```

- 关联 dtd 文件 — 更换 dtd 文件的查找位置

打开Eclipse -> PreFerences - > XML  -> XML Catelog - >add -> 选择File System -> key type 设置为 System ID ->

key值粘贴MyBatis 官方提供了dtd约束

![](http://www.zwer.xyz/picGo/20181228205405.png)





### 3.3.1 配置文件内容(初步)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">

 <configuration>
 	<!-- 用于指定环境 
 		 default: 用于指定使用的环境 id
 	-->
 	<environments default="szxy">
 		<!-- 用于配置开发环境 
 			 id：环境的唯一标识
 		-->
 		<environment id="szxy">
 			<!-- 事务管理器 
 				  type：用于设置 mybatis 采用什么方式管理事务
 				  JDBC 表示采用和 JDBC 一样的事务管理方式
 			-->
 			<transactionManager type="JDBC"></transactionManager>
 			<!-- 
 				数据源/连接池 ，用于配置数据库连接池和数据库连接的参数
 				type: 用于设置 mybatis 是否采用连接池技术
 				pooled 表示 MyBatis 采用连接池技术
 			 --> 			 
 			<dataSource type="pooled">
 				<property name="driver" value="com.mysql.jdbc.Driver"/>
 				<property name="url" value="jdbc:mysql://localhost:3306/MyBatisTable"/>
 				<property name="username" value="root"/>
 				<property name="password" value="root"/>
 			</dataSource>
 		</environment>
 	</environments>
```

## 3.4  定义 pojo 类

此处 略去

## 3.5 Mapper 映射文件 == 数据访问层  Dao

> 在 MyBatis 中， 推荐使用 mapper 作为包名 ，写一个映射配置文件即可 . 
>
> UserMapper.xml 用于 定义要执行的 SQL 语句，同时设定返回结果的类型
>
> Eclipse快捷键： 选中文件，重命名 F2



- UserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
 <!-- 
 	  namespace 表示命名空间 ,可以随意定义，一般情况下写全限定名
 	  MyBatis 管理 SQL 语句是通过 namespace + id 来定位的
 	  namespace 类似于 包名+类名的结构
  -->
<mapper namespace ="cn.szxy.mapper.UserMapper">
	<!--  
		select 标签用于编写查询语句
		id: SQL 语句的唯一标识，类似于方法名
		resultType: 用于设定结果的返回类型(全限定路径)
		如果返回有集合，要写集合泛型的类型
	 -->
	<select id="selAll" resultType="cn.szxy.pojo.User">
		<!-- 注意： SQL 语句不需要写分号哦 ！ -->
		select * from M_user
	</select>
</mapper>
```

- mybatis.xml  

> 添加 扫描映射文件

```xml
	<!--  扫描映射文件  -->
 	<mappers>
 		<mapper resource="cn/szxy/mapper/UserMapper.xml" />
 	</mappers>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">

 <configuration>
 	<!-- 用于指定环境 
 		 default: 用于指定使用的环境 id
 	-->
 	<environments default="szxy">
 		<!-- 用于配置开发环境 
 			 id：环境的唯一标识
 		-->
 		<environment id="szxy">
 			<!-- 事务管理器 
 				  type：用于设置 mybatis 采用什么方式管理事务
 				  JDBC 表示采用和 JDBC 一样的事务管理方式
 			-->
 			<transactionManager type="JDBC"></transactionManager>
 			<!-- 
 				数据源/连接池 ，用于配置数据库连接池和数据库连接的参数
 				type: 用于设置 mybatis 是否采用连接池技术
 				pooled 表示 MyBatis 采用连接池技术
 			 --> 			 
 			<dataSource type="pooled">
 				<property name="driver" value="com.mysql.jdbc.Driver"/>
 				<property name="url" value="jdbc:mysql://localhost:3306/MyBatisTable"/>
 				<property name="username" value="root"/>
 				<property name="password" value="root"/>
 			</dataSource>
 		</environment>
 	</environments>
 	<!--  扫描映射文件  -->
 	<mappers>
 		<mapper resource="cn/szxy/mapper/UserMapper.xml" />
 	</mappers>
 </configuration>
```

- 测试类

> 小插曲： 使用 Eclipse 自带的库 Junit，进行单元测试，无序创建 main 方法

```java
package cn.szxy.Test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import cn.szxy.pojo.User;

public class TestMyBatis {
	public static void main(String[] args) throws IOException {
		//加载 Mybatis 核心文件配置文件
		 InputStream is = Resources.getResourceAsStream("mybatis.xml");
		//构建 SqlSessionFactory 工厂
		SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);
		//获得 SqlSession 对象
		SqlSession session = factory.openSession();
		//通过 SqlSession 对象，执行 SQL 语句
		List<User> list = session.selectList("cn.szxy.mapper.UserMapper.selAll");
		/*** 注意 数据库表中的列名和 pojo 类的成员变量名字必须一致 ***/
		System.out.println(list);
		is.close();
	}
}
```

# 4 MyBatis 配置文件详解 

## 4.1 configuration

​	配置 MyBatis 的环境

## 4.2 environments

用于管理所有的环境，并可以指定默认的使用哪个环境，通过 default 属性确定

## 4.3 environment

用于配置环境， id 属性用于表示唯一标识当前环境

## 4.4  transcation

用于配置事务管理器 

### 4.4.1  type 属性

用于指定以何种方式管理 SQL 语句 

a） JDBC   表示 MyBatis 采用与原生 JDBC 一样的方式管理事务

b）MANAGED: 表示将事务管理交给其他容器进行, 例如 Spring 

# 4.5 `<DataSource> `  

用于配置数据源, 设置 MyBatis 是否使用连接池技术, 并且配置数据库连接的四个参数 

## 4.5.1 type 属性 

用于设置 MyBatis 是否使用连接池技术 

a)   <u>POOLED,</u> 表示采用连接池技术 

b)   UNPOOLED, 表示每次都会开启和关闭连接, 不使用连接池技术 

c)    JNDI, 使用其他容器(例如 Spring)提供数据源 

## 1.6  `<property>`

用于配置数据库连接参数(driver, url, username, password) 

## 1.7 `<mappers> `

用于扫描 mapper 信息 





# 5 Mapper 映射配置文件详解

## 5.1 ` <mapper>`

根元素

## 5.1.1  namespace  属性 

用于指定命名空间，mybatis 是通过 namespace + id 来定位 SQL 语句的，所以必须指定	

namespace. 通常 namespace 被配置为全限定路径

## 5.2 `<select>`

用于定义查询语句（DQL）

### 5.2.1 id 属性

用于表示唯一的 SQL 语句，类似于方法中的方法名

### 5.2.2 resultType 属性

用于设定查询返回的数据类型，要写类型的全限定路径. 如果返回的
是集合类型, 要写集合的泛型的类型





# 6 MyBatis 中常用三个查询方法 

## 6.1 select List

用于查询多条数据的情况，返回值是一个 list 集合 ，如果没有查到任何数据，返回没有元素的集合

（空集合，不是 null）

```java
/**
	 * 查找所有用户
	 * @throws IOException
	 */
	public  static  void selAll() throws IOException{
		InputStream is = Resources.getResourceAsStream("mybatis-cfg.xml");
		SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);
		SqlSession session = factory.openSession();
		
		// 将结果打印在控制台打印输出
		List<User> list = session.selectList("cn.szxy.mapper.UserMapper.selAll");
		for (User user : list) {
			System.out.println(user);
		}
		
		session.close();
	} 
```



## 6.2  selectOne

用于查询单条数据的情况，若查不到返回值结果是 null  

```java
/**
	 * 查找单个用户
	 * @throws IOException
	 */
	public static  void selOne() throws IOException{
		InputStream is = Resources.getResourceAsStream("mybatis-cfg.xml");
		SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);
		SqlSession session = factory.openSession();
		
		User user = session.selectOne("cn.szxy.mapper.UserMapper.selOne");
		System.out.println(user);
		
		session.close();
	}
```





## 6.3 selectMap    --- 重点

用于查询多条数据的情况，多条数据要形成一个 Map 集合。

如果查不到，返回一个空的map集合(null )

```java
/**
	 * 查找所有用户并用户id映射
	 * id 作为 key 键
	 * User对象 作为 value 值
	 * @throws IOException
	 */
	public static  void selMap() throws IOException{
		InputStream is = Resources.getResourceAsStream("mybatis-cfg.xml");
		SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is);
		SqlSession session = factory.openSession();
		
		// 获得结果集
		Map<Integer, User> map = session.selectMap("cn.szxy.mapper.UserMapper.selAll","id");
		// 遍历集合
		Set<Integer> set = map.keySet();
		for (Integer i : set) {
			System.out.println("id="+i+"\t"+map.get(i));
		}
		
		session.close();
	}
```



# 7 Log4J 

## 7.1 Log4J 简介

a） Log4J 是 apache 提供的一款记录日志的工具

b）log4j  既可以将日志信息打印在控制台上，也可以打印输出到一个日志文件中

c）log4j 可以定制日志的输出格式

d）log4j 可以定制日志的级别



## 7.2日志级别

- ##### FATAL 

致命的，表示非常严重的错误，一般是系统错误

- ERROR

错误，表示代码错误，比较严重

-  WARN

警告，不影响程序的运行

- IFNO

信息，表示普通的输出信息

-  DEBUG 

调式，表示程序员人为调用一些信息



## 7.3 log4j 使用 

### 7.3.1 导包

log4j-1.2.17.jar
log4j-api-2.0-rc1.jar
log4j-core-2.0-rc1.jar

### 7.3.2 配置文件

使用 log4j.properties 的配置文件，会设定log4j的设置信息，例如日志的级别，日志的输出格式，

日志的格式等等。

```
# Set root category priority to INFO and its only appender to CONSOLE.
#log4j.rootCategory=DEBUG, CONSOLE
log4j.rootCategory=DEBUG, CONSOLE, LOGFILE

# Set the enterprise logger category to FATAL and its only appender to CONSOLE.
log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE

# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=- %m %c %d{YYYY-MM-DD HH:mm:ss} %n

# LOGFILE is set to be a File appender using a PatternLayout.
log4j.appender.LOGFILE=org.apache.log4j.FileAppender
log4j.appender.LOGFILE.File= D:/test.log
log4j.appender.LOGFILE.Append=true
log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
log4j.appender.LOGFILE.layout.ConversionPattern= - %l%m%n
```

## 7.4 MyBatis 对log4j 的支持 ——定制 SQL 语句输出格式

在项目的 src 目录下添加 log4j.properties 配置文件

```xml
- Logging initialized using 'class org.apache.ibatis.logging.slf4j.Slf4jImpl' adapter. org.apache.ibatis.logging.LogFactory 2019-01-05 21:30:42 
- PooledDataSource forcefully closed/removed all connections. org.apache.ibatis.datasource.pooled.PooledDataSource 2019-01-05 21:30:42 
- PooledDataSource forcefully closed/removed all connections. org.apache.ibatis.datasource.pooled.PooledDataSource 2019-01-05 21:30:42 
- PooledDataSource forcefully closed/removed all connections. org.apache.ibatis.datasource.pooled.PooledDataSource 2019-01-05 21:30:42 
- PooledDataSource forcefully closed/removed all connections. org.apache.ibatis.datasource.pooled.PooledDataSource 2019-01-05 21:30:42 
- Opening JDBC Connection org.apache.ibatis.transaction.jdbc.JdbcTransaction 2019-01-05 21:30:42 
- Created connection 1955915048. org.apache.ibatis.datasource.pooled.PooledDataSource 2019-01-05 21:30:43 
- Setting autocommit to false on JDBC Connection [com.mysql.jdbc.JDBC4Connection@7494e528] org.apache.ibatis.transaction.jdbc.JdbcTransaction 2019-01-05 21:30:43 
- ==>  Preparing: select * from M_user  cn.szxy.mapper.UserMapper.selAll 2019-01-05 21:30:43 
- ==> Parameters:  cn.szxy.mapper.UserMapper.selAll 2019-01-05 21:30:43 
- <==      Total: 6 cn.szxy.mapper.UserMapper.selAll 2019-01-05 21:30:43 
User [id=1, name=小猪, sex=男, age=20]
User [id=2, name=abc, sex=男, age=20]
User [id=3, name=ytj, sex=男, age=20]
User [id=4, name=123, sex=男, age=20]
User [id=5, name=小红, sex=女, age=20]
User [id=6, name=小猪, sex=男, age=22]
- Resetting autocommit to true on JDBC Connection [com.mysql.jdbc.JDBC4Connection@7494e528] org.apache.ibatis.transaction.jdbc.JdbcTransaction 2019-01-05 21:30:43 
- Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@7494e528] org.apache.ibatis.transaction.jdbc.JdbcTransaction 2019-01-05 21:30:43 
- Returned connection 1955915048 to pool. org.apache.ibatis.datasource.pooled.PooledDataSource 2019-01-05 21:30:43 

```

- 修改 log4j.perperties 配置信息

```properties
# Set root category priority to INFO and its only appender to CONSOLE.
log4j.rootCategory=ERROR, CONSOLE
# log4j.rootCategory=DEBUG, CONSOLE, LOGFILE

# 单独输出 SQL 语句
# 方法级别
# log4j.logger.cn.szxy.mapper.UserMapper.selOne=debug;
# 类级别
# log4j.logger.cn.szxy.mapper.UserMapper=debug;
# 包级别
log4j.logger.cn.szxy.mapper=debug;


# Set the enterprise logger category to FATAL and its only appender to CONSOLE.
log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE

# CONSOLE is set to be a ConsoleAppender using a PatternLayout.
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern=- %m %c %d{YYYY-MM-DD HH:mm:ss} %n

# LOGFILE is set to be a File appender using a PatternLayout.
log4j.appender.LOGFILE=org.apache.log4j.FileAppender
log4j.appender.LOGFILE.File= D:/test.log
log4j.appender.LOGFILE.Append=true
log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
log4j.appender.LOGFILE.layout.ConversionPattern= - %l%m%n

```

- 在 mybatis_cfg.xml

  - 设置  setting 

  ```xml
   	<settings>
   	 	<setting name="logImpl" value="LOG4J"/>
   	</settings>	
  ```

  - Mybatis 配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <!--  配置  -->
 <configuration>
 	<settings>
 	 	<setting name="logImpl" value="LOG4J"/>
 	</settings>	
	<environments default="szxy">
		<!--  环境 id 是环境的唯一标识  -->
		<environment id="szxy">
			<!-- 事务管理 -->
			<transactionManager type="JDBC" />
			<!--  数据源 -->
			<dataSource type="pooled">
				<property name="driver" value="com.mysql.jdbc.Driver"/>
				<property name="url" value="jdbc:mysql://localhost:3306/MyBatisTable"/>
				<property name="username" value="root"/>
				<property name="password" value="root"/>
			</dataSource>
		</environment>
	</environments>
	<!--  扫描映射文件  -->
 	<mappers>
 		<mapper resource="cn/szxy/mapper/UserMapper.xml"/>
 	</mappers>
 </configuration>
```





# 8  properties 软编码

- db.properties 数据库配置文件 

> 这些是外部化的, 可替代的属性, 这些属性也可以配置在典型的 Java 属性配置文件中, 或者通过 properties 元素的子元素来传递。

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/MyBatisTable
jdbc.username=root
jdbc.password=root
```

- 其中的属性就可以在整个配置文件中使用,使用可替换的属性来实现动态配置

```xml
<property name="driver" value="${jdbc.driver}"/>
<property name="url" value="${jdbc.url}"/>
<property name="username" value="${jdbc.username}"/>
<property name="password" value="${jdbc.password}"/>
```



- MyBatis 配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <!--  配置  -->
 <configuration>
 	<!-- 加载 properties 外部文件 -->
 	<properties resource="db.properties" />
 
 	<!-- 设置MyBatis对 Log4J 的支持   -->
 	<settings>
 	 	<setting name="logImpl" value="LOG4J"/>
 	</settings>	
	<environments default="szxy">
		<!--  环境 id 是环境的唯一标识  -->
		<environment id="szxy">
			<!-- 事务管理 -->
			<transactionManager type="JDBC" />
			<!--  数据源 -->
			<dataSource type="pooled">
				<property name="driver" value="${jdbc.driver}"/>
				<property name="url" value="${jdbc.url}"/>
				<property name="username" value="${jdbc.username}"/>
				<property name="password" value="${jdbc.password}"/>
			</dataSource>
		</environment>
	</environments>
	<!--  扫描映射文件  -->
 	<mappers>
 		<mapper resource="cn/szxy/mapper/UserMapper.xml"/>
 	</mappers>
 </configuration>
```

# 9   typeAliases 标签配置别名

- mybatis.xml 部分配置

```xml
<typeAliases>
 		<!-- 设置User 类型的别名为 User -->
 		<!-- <typeAlias type="cn.szxy.pojo.User"/> -->
 		<!-- 设置 package 包下的类型别名为 类名 -->
 		<package name="cn.szxy.pojo"/>
 </typeAliases>
```



对于普通的 Java 类型,有许多内建的类型别名。它们都是大小写不敏感的,由于重载的名字,要注意原生类型的特殊处理。 

![](http://www.zwer.xyz/picGo/20190106160532.png)





![](http://www.zwer.xyz/picGo/20190106160547.png)





# 10  带参数的查询 parameterType 

参数类型，用于参数传递

#{}用于使用参数

index  ，索引 ，从0开始

param+数字， param1，param2

如果参数类型是对象，可以通过#{属性名}获取

如果参数类型是map集合，可以通过 	#{key}获取

```xml
<!-- parameterType  参数类型，用于参数传递  -->
	<select id="selByAge" resultType="User" parameterType="int">
		<!-- 
				#{}用于使用参数
				index  ，索引 ，从0开始
		 -->
		select * from M_user where age = #{param1}
	</select>
	<select id="selBy2" resultType="User" parameterType="User">
		<!-- 
			如果参数类型是对象，可以通过#{属性名}获取	
		 -->
		select * from M_user where name= #{name} and age = #{age}
	</select>
	<!-- map 是 Mybatis自己设置  Map 的别名 -->
	<select id="selBy2s" resultType="User" parameterType="map">
		<!-- 
			如果参数类型是Map集合，可以通过#{key键}获取
		 -->
		 select *  from M_user where name=#{uname} and age = #{uage}
	</select>
```

- TestParams.java

```java
package cn.szxy.Test;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

import cn.szxy.pojo.User;

public class TestParams {
	/**
	 *  查询 单个用户
	 *  根据用户 年龄查询
	 */
	@Test
	public void selByAge(){
		SqlSession session = null;
		try {
			session  = new SqlSessionFactoryBuilder()
				.build(Resources.getResourceAsStream("mybatis-cfg.xml"))
				.openSession();
			User user = session.selectOne("cn.szxy.mapper.UserMapper.selByAge", 22);
			System.out.println(user);
			
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(session != null){
				session.close();
			}
		}
	}
	/**
	 *  查询 单个用户
	 *  传入两个参数 name、age
	 * 
	 */
	@Test
	public void selBy2(){
		SqlSession session = null;
		try {
			session  = new SqlSessionFactoryBuilder()
				.build(Resources.getResourceAsStream("mybatis-cfg.xml"))
				.openSession();
			User u = new User();
			u.setName("abc");
			u.setAge("20");
			User user = session.selectOne("cn.szxy.mapper.UserMapper.selBy2", u);
			System.out.println(user);
			
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(session != null){
				session.close();
			}
		}
	}
	@Test
	public void selBy2s(){
		SqlSession session = null;
		try {
			session  = new SqlSessionFactoryBuilder()
				.build(Resources.getResourceAsStream("mybatis-cfg.xml"))
				.openSession();
			
			Map<String,String> map = new HashMap<>();
			map.put("uname", "abc");
			map.put("uage","20");	
			User user = session.selectOne("cn.szxy.mapper.UserMapper.selBy2s", map);
			System.out.println(user);
			
		} catch (IOException e) {
			e.printStackTrace();
		}finally{
			if(session != null){
				session.close();
			}
		}
	}
}

```

# 11  DML 操作 _封装工具类

## 11.1 事务（Transcation）

> 1. 事务是数据库操作的最小单元，特征有ACID，应该保证一个事务中SQL 语句要么同时成功，要么同时都失败，即保证事务的一致性
>
> 2. MyBatis 中配置事务管理器，type属性设置为 JDBC ，表示 MyBatis 采用和原生 JDBC 相同的事务管理机制
> 3. 在MyBatis 执行开始时，将自动关闭自动提交的功能，



## 11.2  封装工具类

```java
package cn.szxy.util;

import java.io.IOException;
import java.io.InputStream;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class MyBatisUtil {
	private static SqlSessionFactory factory;
	static{
		try {
			InputStream is = Resources.getResourceAsStream("mybatis-cfg.xml");
			factory = new SqlSessionFactoryBuilder().build(is);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static SqlSession getSession(){
		SqlSession session = null;
		if(factory!= null){
			 // true 表示在执行SQL之前，不关闭 数据库自动提交事务的功能
			 session = factory.openSession(true);
		}
        // 关闭资源
		return session;
	}
}

```



## 11.3  增删改操作（DML）

```java
package cn.szxy.Test;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import cn.szxy.pojo.User;
import cn.szxy.util.MyBatisUtil;

/**
 * 执行 DML 操作
 * 在 MyBatis内部中 
 * 执行 SQL 语句都采用 executeUpdate 方法 
 * 所以 SqlSession 对象中 insert、update、delete 方法可以通用
 * 使用 insert、update、delete 方法名的好处是 见名知意
 */
public class InsUser {
	@Test
	public void InsUserOne(){
		SqlSession session = MyBatisUtil.getSession();
		User user = new User();
		user.setName("小赵同学222");
		user.setSex("女");
		user.setAge("20");
		int num = session.insert("cn.szxy.mapper.UserMapper.InsUserOne", user);
		if(num > 0){
			//提交事务
			session.commit();
			System.out.println("SUCESS!");
		}else{
			//回滚事务
			session.rollback();
			System.out.println("FAILED");
		}
		//关闭资源
		session.close();
	}
	@Test
	public void UpdateOne(){
		SqlSession session = MyBatisUtil.getSession();
		User user = new User();
		user.setName("小赵");
		user.setAge("20");
		user.setId(4);
		int num = session.update("cn.szxy.mapper.UserMapper.UpdateOne", user);
		if(num > 0){
			//提交事务
			session.commit();
			System.out.println("SUCESS!");
		}else{
			//回滚事务
			session.rollback();
			System.out.println("FAILED");
		}
		//关闭资源
		session.close();
	}
	/**
	 * 不存在的用户id，删除该用户id ，不会报错哦
	 */
	@Test
	public void delOne(){
		SqlSession session = MyBatisUtil.getSession();
	
		int num = session.update("cn.szxy.mapper.UserMapper.delOne", 16);
		if(num > 0){
			//提交事务
			session.commit();
			System.out.println("SUCESS!");
		}else{
			//回滚事务
			session.rollback();
			System.out.println("FAILED");
		}
		//关闭资源
		session.close();
	}
	
}
```

# 12   MyBatis 接口绑定方案

> 在 MyBatis 中提供一套接口绑定方案，程序员可以提供一个接口，然后提供对应接口的 mapper.xml 文件
>
> MyBatis 会自动将接口与 mapper.xml 绑定，实际上，MyBatis就是会根据接口和mapper.xml配置文件创建接口的实现类（动态代理模式），换言之，就可以得到接口类型绑定的实现类

## 12.1 实现方式

### 12.1.1 定义接口

- UserMapper.java  接口

```java
package cn.szxy.mapper;
import java.util.List;
import cn.szxy.pojo.User;

public interface UserMapper {
	
	/**
	 * 查找所有用户
	 * @return
	 */
	List<User> selAll();
}

```

### 12.1.2 编写对应接口的映射文件

注意：id 名和 接口中的方法名 相同

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--
	mapper  映射
	namespace 名字空间  
	namespace + id 确定 SQL 语句 
 -->
<mapper namespace ="cn.szxy.mapper.UserMapper">

	<!-- 查找所有用户 -->
	<select id="selAll" resultType="User">
		select * from M_user
	</select>
</mapper>
```

### 12.1.3  在核心配置文件中扫描mapper

- mybatis-cfg.xml    

MyBatis.xml 核心配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
  <!--  配置  -->
 <configuration>
 	<!-- 加载 properties 外部文件 -->
 	<properties resource="db.properties" />
 
 	<!-- 设置MyBatis对 Log4J 的支持   -->
 	<settings>
 	 	<setting name="logImpl" value="LOG4J"/>
 	</settings>	
 	<!-- typealiases 给类型设置别名-->
 	<typeAliases>
 		<!-- 设置User 类型的别名为 User -->
 		<!-- <typeAlias type="cn.szxy.pojo.User"/> -->
 		<!-- 设置 package 包下的类型别名为 类名 -->
 		<package name="cn.szxy.pojo"/>
 	</typeAliases>
 	
	<environments default="szxy">
		<!--  环境 id 是环境的唯一标识  -->
		<environment id="szxy">
			<!-- 事务管理 -->
			<transactionManager type="JDBC" />
			<!--  数据源 -->
			<dataSource type="pooled">
				<property name="driver" value="${jdbc.driver}"/>
				<property name="url" value="${jdbc.url}"/>
				<property name="username" value="${jdbc.username}"/>
				<property name="password" value="${jdbc.password}"/>
			</dataSource>
		</environment>
	</environments>
	<!--  扫描映射文件  -->
 	<mappers>
 		<!-- <mapper resource="cn/szxy/mapper/UserMapper.xml"/> -->
 		<!-- <mapper class="cn.szxy.mapper.UserMapper"/> -->
 		<package name="cn.szxy.mapper" />
 	</mappers>
 </configuration>
```

### 12.1.4 应用

- TestBind.java     绑定

定义接口的对象接受 UserMapper 实现类对象（由Mybatis 自己创建）

```java
package cn.szxy.Test;

import java.util.List;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import cn.szxy.mapper.UserMapper;
import cn.szxy.pojo.User;
import cn.szxy.util.MyBatisUtil;

public class TestBind {
	@Test
	public void selAll(){
		SqlSession session = MyBatisUtil.getSession();
		//获得 UserMapper 实现类的对象
		UserMapper mapper = session.getMapper(UserMapper.class);
		List<User> list = mapper.selAll();
		for (User user : list) {
			System.out.println(user);
		}
	}
}

```

## 12.2 通过接口方案，解决多参数传递

紧接上述的步骤，查询用户根据用户和密码

### 12.2.1 定义接口中的抽象方法

```java
package cn.szxy.mapper;

import java.util.List;

import org.apache.ibatis.annotations.Param;

import cn.szxy.pojo.User;
import cn.szxy.pojo.User2;

public interface UserMapper {
	
	/**
	 * 查找所有用户
	 * @return
	 */
	public List<User> selAll();
	
	/**
	 * 查找单个用户根据用户名和密码
	 * 
	 *使用 注解 @Param()
	 *用于填写 select 语句的选择参数
	 *构成 map 函数
	 *其实 @Param("username") 相当于键 key
	 *而 String username 相当于 值 value
	 *
	 *当使用 注解@Param后 就不能使用索引 0、 1
	 * 
	 * @param username  用户名
	 * @param password  密码
	 * @return
	 */
	public User2 selByUP( @Param("username") String username,@Param("password") String password);
	
}

```



### 12.2.2 在 UserMapper.xml 中添加 sql 语句

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--
	mapper  映射
	namespace 名字空间  
	namespace + id 确定 SQL 语句 
 -->
<mapper namespace ="cn.szxy.mapper.UserMapper">

	<!-- 查找所有用户 -->
	<select id="selAll" resultType="User">
		select * from M_user
	</select>
	<!-- 查找单个用户根据用户名和密码 -->
	<select id="selByUP" resultType="User2">
		<!-- select * from Test where username= #{param1} and password=#{param2} -->
	<!-- 	select * from Test where username=#{username} and password=#{password} -->
		select * from Test where username=#{0} and password=#{1}
	</select>
</mapper>
```



### 12.2.3 应用

```java
package cn.szxy.Test;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import cn.szxy.mapper.UserMapper;
import cn.szxy.pojo.User2;
import cn.szxy.util.MyBatisUtil;

public class TestSel {
	@Test
	public void selByUP(){
		SqlSession session = MyBatisUtil.getSession();
		UserMapper mapper = session.getMapper(UserMapper.class);
		User2 user = mapper.selByUP("小红","123");
		System.out.println(user); 
	}
}
```

### 12.2.4 总结

#### 1   方式一 使用索引0、1 或者 参数param1 、param2 

```xml
<!-- 查找单个用户根据用户名和密码 -->
	<select id="selByUP" resultType="User2">
        select * from Test where username= #{0} and password=#{1}
		<!-- select * from Test where username= #{param1} and password=#{param2} -->
	</select>
```



#### 2  方式二 使用注解 @Param 来使用自己设定的值 或者使用 参数param1 、param2

```xml
<!-- 查找单个用户根据用户名和密码 -->
	<select id="selByUP" resultType="User2">
		<!-- select * from Test where username= #{param1} and password=#{param2} -->
		select * from Test where username=#{username} and password=#{password} 
	</select>
```

```java
	/**
	 * 查找单个用户根据用户名和密码
	 * 
	 *使用 注解 @Param()
	 *用于填写 select 语句的选择参数
	 *构成 map 函数
	 *其实 @Param("username") 相当于键 key
	 *而 String username 相当于 值 value
	 *
	 *当使用 注解@Param后 就不能使用索引 0、 1
	 * 
	 * @param username  用户名
	 * @param password  密码
	 * @return
	 */
public User2 selByUP( @Param("username") String username,@Param("password") String password);
```



# 13 动态 SQL   dynamic 

 根据条件的不同，sql 语句也会随之动态的改变

> MyBatis 的一个强大的特性之一通常是它的动态 SQL 能力。如果你有使用 JDBC 或其他相似框架的经验,你就明白条件地串联 SQL  字符串在一起是多么的痛苦,确保不能忘了空格或在列表的最后省略逗号。动态 SQL 可以彻底处理这种痛苦。 
>
> 通常使用动态 SQL 不可能是独立的一部分,MyBatis 当然使用一种强大的动态 SQL 语言来改进这种情形,这种语言可以被用在任意映射的 SQL  语句中。 
>
> 动态 SQL 元素和使用 JSTL 或其他相似的基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis  3 大大提升了它们,现在用不到原先一半的元素就能工作了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。 

- if  
- choose (when, otherwise)  
- trim (where, set)  
- foreach 

## 13.1  `< where>`   `<if>`

> if 标签用于进行条件判断， test 用于指定判断条件，为了拼接条件，在 SQL 语句 的后面添加 1=1 的恒成立
>
> where 标签 用于管理 where **子句**，有如下的功能
>
> a)  如果没有条件，不会生成 where 关键字
>
> b）如果有条件，会自动生成 where 关键字
>
> c）如果第一个条件中有 and ，去除之



- UserMapper.xml

```xml
	<!-- 查找所有用户 -->
	<select id="sel" resultType="User">
		select * from Test 
		<where>  
			 <!--  test 设置判断条件
				   相当于 if语句中的判断条件
			 -->
			<if test="username !=null and username !='' "> 
				and username = #{username}
			</if>
			<if test="password !=null and password !='' ">
				and password = #{password}
			</if>			
		</where>
	</select>
```

## 13.2  `<choose>` `<when>` 

> 类似与 Java中 switch... case ...

- UserMapper.xml

```xml
	<!--  优化查找所有用户  -->
	<select id="sel" resultType="User">
		select * from Test
		<where>
			<choose>
				<when test="username != null and username != '' ">
					username = #{username}
				</when>
				<when test="password !=null and password != '' ">
					password = #{password}
				</when>
				<otherwise>
					where 1=1 
				</otherwise>
			</choose>
		</where>
	</select>	
```



## 13.3 `<set>`

>  set  标签用于管理更新语句

- UserMapper.xml

```xml
	<!-- 更新用户信息  -->
	<update id="updateUser">
		update Test
		<set>
			<!-- 优化 防止没有填写 username or password 修改信息 -->
			id = #{id},
			<if test="username !=null and username !='' ">
				 username = #{username},
			</if>
			<if test="password !=null and password !='' ">
				 password = #{password},
			</if>
		</set>
		where id = #{id}
	</update>
```

## 13.3 `<trim>`

> 相当于 where 和 set 标签的作用，甚至可以补充where和set 标签做不到的功能
>
> 用于在前后增加或者删除一些内容
>
> a）prefix 		       表示添加前缀
> b）prefixOverriedes 表示覆盖前面的内容
> c） suffix 		       表示添加后缀
> d）sufficOverrides    表示覆盖后面的内容

- UserMapper.xml

```xml
<!-- 使用 trim  -->
	<update id="updateUser">
		<!-- 
			prefix 			   表示添加前缀
			prefixOverriedes 表示覆盖前面的内容
			suffix 			   表示添加后缀
			sufficOverrides  表示覆盖后面的内容
		 -->
			update  Test 
			<trim prefix="set" prefixOverrides="" suffix=""  suffixOverrides=",">
				  username = #{username},
			</trim>
			where id = #{id}
	</update>
```



## 13.4  `<bind>`

> bind 标签对传进来的数据进行在加工

- UserMapper.xml

```xml
<!--  优化查找所有用户  -->
	<select id="sel" resultType="User">
		select * from Test
		<where>
			<choose>
				<when test="username != null and username != '' ">
				<!--  
				  		bind 标签 对传入的数据进行再加工
				  	         用 value的 %usename% 修饰  #{}  
				   -->
				   <bind name="username" value="'%' + username + '%' "/>
					username like #{username}  <!-- 模糊查询 -->
				</when>
				<when test="password !=null and password != '' ">
					password = #{password}
				</when>
				<otherwise>
					where 1=1
				</otherwise>
			</choose>
		</where>
	</select>	
```

注意： `  <bind name="username" value="'%' + username + '%' "/>`  中  value 字符串的拼接

## 13.5 foreach 

> 用于 在 SQL 语句中遍历集合参数，在 in 查询中使用
>
> collection ： 表示待遍历的集合
>
> open： 表示设置开始的符号
>
> item:  表示迭代变量
>
> separator: 表示项目分隔符
>
> close： 表示设置结束的符号

```xml
<!-- 使用 foreach 标签 -->
	<select id="selIn" parameterType="int" resultType="User">
		select 
			<include refid="psql" />
		from  Test where id in 
		<foreach item="item" open="(" separator="," close=")" collection="list">
			#{item}
		</foreach>
	</select>
```



## 13.6 `<sql>` `<include>`

> sql 标签配合 include 标签使用，实现 sql 语句的复用，减少代码的书写
>
> <sql>用于提取 SQL 语句 
>
> <include> 用于 引用 SQL 语句

```xml
<!--  这里要复用的 sql 语句  -->
	<sql id="psql">id,username,password</sql>
<!-- 查找所有用户 -->
	<select id="sel" resultType="User">
		select
			 <include refid="psql"/>
	   from Test 
		<where>  
			 <!--  test 设置判断条件
				   相当于 if语句中的判断条件
			 -->
			<if test="username !=null and username !='' "> 
				and username = #{username}
			</if>
			<if test="password !=null and password !='' ">
				and password = #{password}
			</if>			
		</where>
	</select>
```

# 14   MyBatis 的缓存机制

> a）缓存用于提交查询效率
>
> b） MyBatis 的缓存是使用 SQL 标签的 ID 作为缓存的唯一标识的。
>
> 执行相同的标签可以使用缓存。不同的标签不能使用缓存。
>
> c）MyBatis 中有两种缓存机制



## 14.1 一级缓存

> a）线程级别的缓存,默认开启，SqlSession的缓存
>
> b）在一个 SqlSession 生命周期中有效， SqlSession 关闭，缓存清空
>
> 基于 id 查询并且是同个 SqlSession 对象上



## 14.2 二级缓存

> a）进程级别的缓存， SqlSessionFactory 的缓存
>
> b） 在一个 SqlSessionFactory 生命周期中有效，可以在多个 SqlSession 生命周期中共享。
>
> c）默认关闭，需要使用的时候，要为某个命名空间开启二级缓存 (在mapper.xml 中配置 <cache>)

```xml
	<!-- 开启二级缓存 ,要求实体类进行序列化 或者设置 readOnly的属性为 true  -->
	<cache readOnly="true"/>
```

# 15  列名和属性名不一致问题_resultMap标签

> 有两种解决方式：
>
> a） 给列名起别名
>
> b） 不使用 resultType，改用resultMap

```xml
<resultMap type="User" id="rmap">
		<!-- 
			设置 主键属性
		 -->
		<id column="id" property="id1"/>
		<!-- 
			设置其他非主属性
		 -->
		<result column="username" property="username1"/>
		<result column="password" property="password1"/>
	</resultMap>
	<select id="selAll"  resultMap="rmap">
		select * from Test
	</select>
```

# 16 多表关联查询

## 16.1   设计表-表结构

- 设计 Student表和 class 表，student表中的字段有id,name,age,gender,cid
- class表中的字段有 id（作为主键）,name ,room

```sql
use mybatistable;
-- show create table test;

drop table t_student;
create table t_student(
	id int(10) not null auto_increment,
	name varchar(30) not null,
	age int(3) not null,
	gender char(5) not null,
	cid int(10) not null,
	constraint pk_id primary key(id),
	constraint uk_name unique(name),
	constraint fk_cid foreign key(cid) references t_class(id)
)engine=InnODB,charset=utf8

drop table t_class;
create table t_class(
	id int(10) not null auto_increment,
	name varchar(20) not null,
  room varchar(20) not null,
	constraint pk_id primary key(id),
	constraint uk_name unique(name)
)engine=InnoDB,charset=utf8;

-- 测试数据
insert into t_class values(1001,'软件工程','工B207');
insert into t_class values(1002,'计算机科学与技术','工B201');
insert into t_class values(1003,'网络工程','工B203');
insert into t_class values(1004,'物联网工程','工B206');


truncate table t_student;
insert into t_student values(2016110101,'小王',25,'男',1001);
insert into t_student values(2016110202,'小赵',21,'女',1002);
insert into t_student values(2016110303,'小军',20,'男',1003);
insert into t_student values(2016110404,'小红',22,'男',1004);
insert into t_student values(2016110405,'小李',20,'男',1004);


-- 查表
select * from t_class;
select * from t_student;

-- 查找每个学生对应的班级号
select 
s.id,s.name,s.age,s.gender,c.id as cid
from t_student s,t_class c 
where s.cid = c.id

select 
	s.id sid,s.name sname,s.age sage,s.gender sgender,c.id cid ,c.name cname,c.room croom
from t_student s
left join t_class c
on s.cid =  c.id

-- 查询每班的人数总和
select c.id cid,count(*) as '班级总数'
from t_class c ,t_student s
where s.cid = c.id
group by c.id



```

## 16.2  业务装配实现多表查询(多对一)

mapper 层 只做单表查询操作，在 service 层进行手动装配，实现关联查询的结果。

- 实体类

创建班级类(Clazz) 和学生类(Student) ，并在Student类中加一个Clazz类型的属性，用于表示学生的班级信息。

- mapper 层

提供 StudentMapper 和ClazzMapper ，StudentMapper 查询所有学生信息，ClazzMapper 根据根据编号查询班级信息。

```xml
<select id="selAll" resultMap="smap">
		select * from t_student
	</select>
```

```xml
<select id="selById" resultMap="cmap" parameterType="int">
		select * from t_class where id = #{0}
</select>
```

- 新增的层  - services 层

调用 mapper 层，先查询所有学生，再根据每个学生所在的班级编号查询班级信息，手动进行组装，称之为业务装配

```java
public List<Student> selAll() {
		SqlSession session = MyBatisUtil.getSqlSession();
		StudentMapper stuMapper = session.getMapper(StudentMapper.class);
		ClazzMapper clsMapper = session.getMapper(ClazzMapper.class);
		List<Student> students = stuMapper.selAll();
		for (Student stu : students) {
			/**  业务装配    
			 * 	  根据学生的班级号查询对应的班级信心
			 * 	 再添加到 学生类中
			 * ***/
			Clazz cls = clsMapper.selById(stu.getCid());
			stu.setClazz(cls);
		}
		return students;
	}
```

- Test 层

```java
public class TestMyBatis {
	@Test
	public void test03(){
		StudentService stuService = new StudentServiceImpl();
		List<Student> list = stuService.selAll();
		for (Student stu : list) {
			System.out.println(stu);
		}
	}
} 
```



## 16.3 resultMap association   N+1 查询（多对一）

>   优点：使用的  SQL 语句简单，都是单表查询
>   缺点：执行 SQL 语句的次数多 N+1 次，效率低

- pojo  层

  创建班级类(Clazz) 和学生类(Student) ，并在Student类中加一个Clazz类型的属性，用于表示学生的班级信息。

- mapper 层

  在 StudentMapper.xml 中，使用新的标签，resultMap标签下的association标签，用于关联其他表，做多表查询使用，需要传入参数进去 column。

```xml
<resultMap type="Student" id="smap">
			<!--  设置主键的id  -->
			<id column="id" property="sid"/>
			<!-- 设置非主属性映射 -->
			<result column="name" property="sname"/>
			<!-- 
					若没有手动映射cid，则在查询结果中 cid 等于 0
					由于 MyBatis 的机制，一个相同的属性只使用 
					若想使用多次，则需要手动映射
			 -->
			<result column="cid" property="cid"/>
			<!-- 关联到 clazz 表，根据 cid 查询班级信息 -->
			<association property="clazz" select="cn.szxy.mapper.ClazzMapper.selById" column="cid" />
	</resultMap>
	<select id="selAll" resultMap="smap">
		select * from t_student
	</select>
```

- services 层

```java
public List<Student> selAll() {
    SqlSession session = MyBatisUtil.getSqlSession();
    StudentMapper stuMapper = session.getMapper(StudentMapper.class);
    List<Student> students = stuMapper.selAll();
    return students;
}
```

- Test 层

```java
package cn.szxy.test;


import java.util.List;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;

import cn.szxy.mapper.ClazzMapper;
import cn.szxy.mapper.StudentMapper;
import cn.szxy.pojo.Clazz;
import cn.szxy.pojo.Student;
import cn.szxy.services.StudentService;
import cn.szxy.services.StudentServiceImpl;
import cn.szxy.util.MyBatisUtil;

public class TestMyBatis {
	/**
	 *   N+1 查询
	 *   1 表示查询所有的学生信息
	 *   N 表示查询每个学生的班级编号对应的班级信息
	 *   
	 *   优点：使用的  SQL 语句简单，都是单表查询
	 *   缺点：执行 SQL 语句的次数多 N+1 次，效率低
	 */
	@Test
	public void test01(){
		StudentService stuService = new StudentServiceImpl();
		List<Student> list = stuService.selAll();
		for (Student stu : list) {
			System.out.println(stu);
		}
	}
}
```



## 16.4  resultMap association 的关联查询(多对一)

> a）在 ClazzMapper.xml  中定义多表连接查询 SQL  语句，一次性查到所有需要的数据
>
> b）通过 <resultMap> 定义映射关系，并通过 collection 标签指定集合的泛型的映射关系，可以把collection标签看成一个resultMapper 标签使用，**ofType**属性表示集合的泛型，可以写全限定路径名或别名

- 实体类

  创建班级类(Clazz) 和学生类(Student) ，并在Student类中加一个Clazz类型的属性，用于表示学生的班级信息。

- mapper 层

```xml
<resultMap type="Student" id="smap">
			<!--  设置主键的id  -->
			<id column="sid" property="sid"/>
			<!-- 设置非主属性映射 -->
			<result column="sname" property="sname"/>
			<!-- 
					若没有手动映射cid，则在查询结果中 cid 等于 0
					由于 MyBatis 的机制，一个相同的属性只使用 
					若想使用多次，则需要手动映射
			 -->
			<result column="sage" property="age"/>
			<result column="sgender" property="gender"/>
			<result column="cid" property="cid"/>
			<!-- 关联到 clazz 表，根据 cid 查询班级信息 -->
			<association property="clazz" javaType="Clazz">
				<id column="cid" property="cid"/>	
				<result column="cname" property="cname"/>
				<result column="croom" property="croom"/>
			</association>
	</resultMap>
	<select id="selAll" resultMap="smap">
		select 
			s.id sid,s.name sname,s.age sage,s.gender sgender,c.id cid ,c.name cname,c.room croom
		from t_student s
		left join t_class c
		on s.cid =  c.id
	</select>
```

- service  层

```java
 public List<Student> selAll() {
		SqlSession session = MyBatisUtil.getSqlSession();
		StudentMapper stuMapper = session.getMapper(StudentMapper.class);
		List<Student> students = stuMapper.selAll();
		return students;
	}
```



- Test 层 

```java
@Test
public void test01(){
    StudentService stuService = new StudentServiceImpl();
    List<Student> list = stuService.selAll();
    for (Student stu : list) {
    System.out.println(stu);
	}
}
```



## 16.5  resultMap association   N+1 查询（一对多）

> 注意关联其他表 使用 collection标签,其中属性有：
>
> property: 指定要关联的一个集合
>
> select: 设定要继续引用查询， namespace+id
>
> column:  查询时需要传递的列

- 实体类

创建 Student 类和 Clazz 类，其中在 Clazz 类添加属性为泛型为 Student 的 List 集合，用于查询每个班级信息中对应的学生信息

- mapper 层

提供 ClazzMapper 和 StudentMapper ，ClazzMaper 查询所有班级信息， StudentMapper 根据班级编号查询学生信息。

```xml
<resultMap type="clazz" id="cmap">
		<id column="cid" property="cid"/>
		<result column="cname" property="cname"/>
		<result column="croom" property="croom"/>
	 	<collection property="students" select="cn.szxy.mapper.StudentMapper.selByCId" column="cid" />
	</resultMap>
	
	<select id="selAll" resultMap="cmap">
		select
		c.id cid,c.name cname,c.room croom 
	   from t_class c  
	</select>
```

```xml
<select id="selByCId" resultType="student" parameterType="int">
		select 
		s.id sid,s.name sname,s.age,s.gender,s.cid
		from t_student s where cid = #{0}
	</select>
```

- services 层

```java
public List<Clazz> selAll() {
		SqlSession session = MyBatisUtil.getSqlSession();
		ClazzMapper clsMapper = session.getMapper(ClazzMapper.class);
		List<Clazz> list = clsMapper.selAll();
		return list;
	}
```

- Test  层

```java
@Test 
	public void test03(){
		SqlSession session = MyBatisUtil.getSqlSession();
		ClazzMapper mapper = session.getMapper(ClazzMapper.class);
		List<Clazz> list = mapper.selAll();
		for (Clazz clazz : list) {
			System.out.println(clazz);
		}
	}
```



## 16.6resultMap 关联查询（一对多）

> a）在 ClazzMapper.xml  中定义多表连接查询 SQL  语句，一次性查到所有需要的数据
>
> b）通过 <resultMap> 定义映射关系，并通过 collection 标签指定集合的泛型的映射关系，可以把collection标签看成一个resultMapper 标签使用，**ofType**属性表示集合的泛型，可以写全限定路径名或别名

-  实体类

创建 Student 类和 Clazz 类，其中在 Clazz 类添加属性为泛型为 Student 的 List 集合，用于查询每个班级信息中对应的学生信息

- mapper 层

```xml
<resultMap type="clazz" id="cmap">
		<id column="cid" property="cid"/>
		<result column="name" property="cname"/>
		<result column="room" property="croom"/>
		<!--  除了指定 类型为 集合list 还需要指定集合的泛型  oftype-->
	 	<collection property="students" javaType="list" ofType="Student">
	 		<id column="id" property="sid"/>
	 		<result column="name" property="sname"/>
	 		<result column="age" property="age"/>
	 		<result column="gender" property="gender"/>
	 		<result column="cid" property="cid"/>
	 	</collection>
	</resultMap>
	<select id="selAll" resultMap="cmap">
			select 
			c.id cid,c.name,c.room,s.id,s.name,s.age,s.gender 
			from t_class c
			left join t_student s
			on  c.id = s.cid
	</select>
```

- services 层

```java
public List<Clazz> selAll() {
		SqlSession session = MyBatisUtil.getSqlSession();
		ClazzMapper clsMapper = session.getMapper(ClazzMapper.class);
		List<Clazz> list = clsMapper.selAll();
		return list;
	}
```

- Test 层

```java
@Test 
	public void test03(){
		SqlSession session = MyBatisUtil.getSqlSession();
		ClazzMapper mapper = session.getMapper(ClazzMapper.class);
		List<Clazz> list = mapper.selAll();
		for (Clazz clazz : list) {
			System.out.println(clazz);
		}
	}
```

- 注意：

查询班级中 学生的信息是一个集合的形式

<collection>标签用于关联一个集合，而<association>关联一个对象

在使用 resultMap 关联查询时，注意collection标签中属性 oftype 设置泛型

若不设置泛型，程序报错。



## 16.7 通过 Auto-Mapping 实现多表查询（多对一）

> 优点：不需要使用手动映射，resultmap标签，简单
>
> 缺点：格式要求严格，而且只能使用同类型的数据库
>
> 如：MySql 中字符串原样输出采用 `` `,而 Oracle 数据库中字符串原样输出采用双引号 `" "`

- mapper 层

```xml
	<!-- resultType 使用 自动映射   -->
	<select id="selAll"  resultType="student">
		select 
			s.id sid,s.name sname,s.age,s.gender,s.cid,c.id `clazz.cid`,c.name `clazz.name`, c.room `clazz.room`
		from t_student s
		left join t_class c
		on s.cid =  c.id
	</select>
```

- Test 层

```java
@Test
	public void test01(){
		StudentService stuService = new StudentServiceImpl();
		List<Student> list = stuService.selAll();
		for (Student stu : list) {
			System.out.println(stu);
		}
	}
```



# 17   注解开发

## 17.1 注解概况

> 注解用于描述代码的代码

例如：@Test(用于描述方法进行 junit 测试), @Override（用于描述方法的重写）,@Param(用于描述属性的名称)

a )  注解的格式 @(xxx)，使用需要**导包**

b ）使用注解简化配置文件，但是注解有时候不友好，甚至会很麻烦

c ）关于注解的属性

 -  属性的设定方式：属性名 = 属性值

d ）关于属性值的类型

- 基本类型和 String ，可以使用**双引号**的形式

- 数组形式，name = {值1，值2，...},如果数组元素**只有一个**，可以省略大括号

- 对象类型 ，**对象=@对象名(属性)**

- 如果属性是该注解的**默认属性**，而且该注解只配置一个属性，可以将属性名省略
- 注解和配置文件可以配合使用

## 17.2  Mybatis 中常见的注解

### 17.2.1 CRUD    注解

@select： 类似于 ` <select>`

@Insert:  类似于 `<Insert>`

@Update: 类似于 `<update>`

@Delete:  类似于  `<delete>`

-  mapper 层

```java
public interface StudentMapper {
	
	@Select("select s.id sid,s.name sname,s.age,s.gender,s.cid from t_student s")
	List<Student> selAll();
	
	@Insert("insert into t_student values(default,#{sname},#{age},#{gender},#{cid})")
	int InsOne(Student stu);
	
	@Update("update t_student set age = #{1} where id = #{0}")
	int UpdOne(int id,int age);
	
	@Delete("delete from t_student where id = #{sid}")
	int delOne(@Param("sid") int id);
}

```

### 17.2.2  使用注解关联查询

> @Results 类似于 `<ResultMap>`标签
>
> @Result 类似于 `<Result>` 和` <id> `标签
>
> 当 @Result 当做 `<id>` 标签时，注意添加` id= true`
>
> @one 类似于与 `<association>`标签

- mapper 层

```java
@Select("select * from t_student")	
	@Results(value = {
			@Result(column="id",property="sid",id=true),
			@Result(column="name",property="sname"),
			@Result(column="age",property="age"),
			@Result(column="gender",property="gender"),
			@Result(column="cid",property="cid"),
			@Result(property="clazz",one=@One(select="cn.szxy.mapper.ClazzMapper.selByCid"),column="cid")
	})
	List<Student> selAll();
```

​	

```java
@Select(value = {"select * from T_class where id=#{id}"})	
	@Results(value = {
			@Result(column="id",property="cid",id=true),
			@Result(column="name",property="cname"),
			@Result(column="room",property="croom")
	})
	public Clazz selByCid(@Param("id") int id);
```

# 18   MyBatis 运行原理

> 用于技术面试

## 18.1  运行过程中涉及类和接口

-  **Resources(C)**

 用于加载 MyBatis 核心配置文件  xml

-  **XMLConfigBuilder(C)** 

用于解析 xml 文件(核心配置文件)  

- **Configuration(C)**

用于存放 xml 文件解析后的结果 

- **DefaultSqlSessionFactory(C)**

是 SqlSessionFactory(I) 的 实现类, 创建时需要使用 Configuration 对象 

- **SqlSession( I )**

是 MyBatis 操作的核心 

- **DefaultSqlSession(C)**

是 SqlSession 接口的实现类 

- **TransactionFactory(I)**

用于生产 Transaction 对象 

- **Transaction(I)**

用于表示操作数据库的事务对象 

-  **Executor(I)**

是 MyBatis 的核心执行器, 类似于 jdbc 中的 Statement, 常用的实现类是 SimpleExecutor 



## 18.2 **文字描述**

​	当 MyBatis 运行开始时, 先要通过 Resources 加载核心配置文件, 之后使 XMLConfigBuilder 

对配置文件进行解析, 将解析结果封装为 Configuration 对象, 接着, 使用Configuration 对象构建

一个DefaultSqlSessionFactory 对象, 至此, SqlSession 工厂构建完成. 

​	接下来, 通过工厂对象调用 openSession 方法创建 SqlSession 对 象 . 在 这 个 过 程 中 , 需 

要 通 过TransactionFactory 生成 Transaction 对象, 并且, 还需要创建核心执行器 Executor 对

象, 之后, 通过这些对象来创建DefaultSqlSession 对象, 至此, SqlSession 对象创建成功. 

​	之后, 通过 SqlSession 对象执行相应的操作, 如果执行成功, 调用 commit 方法提交事务; 如

果失败, 调用rollback 方法事务回滚. 最后, 调用 close 方法关闭session 资源. 以上, 就是 MyBatis 

的运行原理.



