---
title: 20190919 Python 核心特性
date: 2019-09-19
categories: ['Python']
---

## 生成器 ##

> 1. 能够计算，2.返回值

#### 生成器产生及元素方式 ####

```python
"""
    产生生成器的方式：
        1. 生成器推导式 : g1 = (x for x in  range(5))
        2. 在函数中使用  yield 关键字
"""


def test():
    """ 迭代器 """
    for i in range(3):
        yield i
        pass


if __name__ == '__main__':
    g1 = (x for x in range(5))
    print("g1:的类型", type(g1))
    print(g1.__next__())
    print(next(g1))
    print(g1.send(None))  # 第一次 send 必须传入 None 值，后面的参数随便。此方式通常不常用
    print(g1.send("suibian "))
    print(g1.__next__())
    #  print(g1.__next__())  # 超过生成器范围报异常 StopIteration

    """
        yield 
    """
    print("test:", type(test()))
    list1 = list(x for x in test())
    print("list1:", list1)

```

#### 生成器产生元素方式 ####

- `__next___`
- `next()`
- for 循环遍历
- send 方法，不常用

#### 生成器与列表比较 ####

| 类型   | 时间   | 内存   |
| ------ | ------ | ------ |
| 生成器 | 时间长 | 开销大 |
| 列表   | 时间段 | 开销小 |

**测试**

```python
import sys, time

"""
    生成器与列表比较
    1. 时间
    2. 内存
    
"""

if __name__ == '__main__':
    """
        存储 1- 10000 之间的偶数 
    """
    # list1 = []
    # for i in range(2, 10000, 2):
    #     list1.append(i)
    # print("list1",list1)
    # """
    #     列表推导式
    # """
    # list2 = [x for x in range(2, 10000, 2)]
    # print("list2:", list2)
    # list3 = [x for x in range(1, 10000) if x % 2 == 0]
    # print("list3:", list3)
    # list4 = [a + b for a in '123' for b in 'xyz']
    # print("list4:", list4)

    """
        使用列表推导式生成 
    """
    time.clock()
    list5 = [x for x in range(2, 10000000, 2)]
    end_time = time.clock()  # 0.2045024
    print("列表所花费的时间: {}".format(end_time))
    print("列表内存开销:", sys.getsizeof(list5))

    """
        使用生成器生成
    """
    time.clock()
    g1 = (x for x in range(2, 10000000, 2))
    end_time2 = time.clock() - end_time  # 3.2e-06
    print("生成器所花费的时间:{}".format(end_time2))
    print("生成器内存开销:", sys.getsizeof(g1))
    # list6 = [x for x in g1]
    # print("list6", list6)

```

### 迭代器 ###

> 能够被 next() 访问，	并不断返回下一个值为新的对象
>
> isinstance(对象 ，类型)  判断对象的类型，返回 True or False

| 可迭代性                | 迭代器 |
| ----------------------- | ------ |
| 集合类 list tuple  dict | 生成器 |
| 生成器 generator        |        |

```python
"""
    迭代器： 能够被 next() 内置函数访问，并返回下一个值为新的对象

    可迭代性
        1. 集合   list tuple dict
        2. 生成器 generator
    迭代器
        生成器
"""
from collections import Iterable, Iterator

if __name__ == '__main__':
    g1 = (_ for _ in range(5))
    print(next(g1))
    print("g1的类型为：", type(g1))
    print("生成器是否具有可迭代性: ", isinstance(g1, Iterable))
    print("生成器是否是迭代器", isinstance(g1, Iterator))

    list1 = [x for x in range(5)]
    if isinstance(list1, Iterable):
        print("list 具有可迭代性.")
        if isinstance(list1, Iterator):
            print("list 是迭代器")
            print(next(list1))
        else:
            print("list 不是迭代器")
    else:
        print("list 不具有可迭代性")

    # tuple1 = (1, 2, 3)
    tuple1 = tuple(list1)
    if isinstance(tuple1, Iterable):
        print("tuple 具有可迭代性.")
        if isinstance(tuple1, Iterator):
            print("tuple 是迭代器")
            print(next(tuple1))
        else:
            print("tuple 不是迭代器")
    else:
        print("tuple 不具有可迭代性")

    dict1 = dict(a=1, b=2)
    if isinstance(dict1, Iterable):
        print("dict 具有可迭代性.")
        if isinstance(dict1, Iterator):
            print("dict 是迭代器")
            print(next(tuple1))
        else:
            print("dict 不是迭代器")
    else:
        print("dict 不具有可迭代性")



    # 将可迭代对象转为迭代器
    print("将可迭代对象转为迭代器")
    list1 = iter(list1)
    if isinstance(list1, Iterator):
        print("list 是迭代器")
        print(next(list1))
        print([x for x in list1])
    else:
        print("list 不是迭代器")

```

### 闭包 ###

```python
"""
    闭包： 一种特殊的函数
    闭包创建的条件
    1. 存在嵌套函数（外部函数和内部函数）
    2. 内部函数需要使用外部函数的参数
    3. 外部函数需要返回内部函数
    闭包的使用
"""


def outer_func(num1):
    """ 使用闭包方式， 计算两数之和"""

    def inner_func(num2):
        # 声明外部变量
        nonlocal num1
        num1 += 1
        return num1 + num2

    # 返回内部函数
    return inner_func


result = outer_func(10)
print(result(10))
print(result(20))

```

#### 闭包与函数 ####

```python
"""
    使用闭包求两个二维坐标之间的距离 （x1, y1） (x2, y2)

    将闭包与函数之间做对比
"""
import math


def func_dist(x1, y1, x2, y2):
    """ 函数方式 """
    return math.sqrt(((x1 - x2) ** 2) + ((y1 - y2) ** 2))


def outer_func_dist(x1, y1):
    """ 闭包方式 """

    def inner_func_dist(x2, y2):
        return math.sqrt(((x1 - x2) ** 2) + ((y1 - y2) ** 2))

    return inner_func_dist


"""
    计算点(10,10) 和点(20, 20) 分别距原点(0, 0) 之间的距离
"""
distance1 = func_dist(0, 0, 10, 10)
distance2 = func_dist(0, 0, 20, 20)
print("点(10, 10) 与原点间的距离:{}".format(distance1))
print("点(20, 20) 与原点间的距离:{}".format(distance2))

print("==" * 22)

inner_func_dist = outer_func_dist(0, 0)
distance3 = inner_func_dist(10, 10)
distance4 = inner_func_dist(20, 20)
print("点(10, 10) 与原点间的距离:{}".format(distance3))
print("点(20, 20) 与原点间的距离:{}".format(distance4))


```

#### 闭包高级使用 ####

>   使用闭包**在不修改源代码的情况下，添加新的功能**
>
>   符合开闭原则

```python
""""
     闭包的高级用法：
        使用闭包在不修改源代码的情况下，添加新的功能

    开闭原则： 对修改关闭，对增加新功能开放
"""
import time


def writeLog(func):
    """
        在调用其他函数时，记录函数的名称，以及调用的时间
    """
    with open('log.txt', 'a', encoding='utf-8') as file:
        file.write(func.__name__)
        file.write('\t')
        file.write(time.asctime())
        file.write('\n')


def outer_func(func):
    """ 采用闭包方式 ,"""

    def funcIn():
        writeLog(func)
        func()

    return funcIn


def fun1():
    # writeLog(fun1)
    print("我是功能1 ...")


def fun2():
    # writeLog(fun2)
    print("我是功能2 ...")


fun1 = outer_func(fun1)
fun2 = outer_func(fun2)

fun1()
fun2()

```

## 装饰器模式 ##

> 通常与闭包紧密结合使用, 简化了闭包函数的调用  
>
> 使用：  @闭包外部函数名，将其放在指定的函数头上即可

```python
""""
     闭包的高级用法：
        使用闭包在不修改源代码的情况下，添加新的功能

    开闭原则： 对修改关闭，对增加新功能开放

    装饰器： 通常与闭包紧密结合使用

"""
import time


def writeLog(func):
    """
        在调用其他函数时，记录函数的名称，以及调用的时间
    """
    with open('log.txt', 'a', encoding='utf-8') as file:
        file.write(func.__name__)
        file.write('\t')
        file.write(time.asctime())
        file.write('\n')


def outer_func(func):
    """ 采用闭包方式 ,"""

    def funcIn():
        writeLog(func)
        func()

    return funcIn


# 装饰器
@outer_func
# fun1 = outer_func(fun1)
def fun1():
    # writeLog(fun1)
    print("我是功能1 ...")


@outer_func
# fun2 = outer_func(fun2)
def fun2():
    # writeLog(fun2)
    print("我是功能2 ...")


# fun1 = outer_func(fun1)
# fun2 = outer_func(fun2)

fun1()
fun2()

```

### 通用装饰器 ###

> 解决不同函数中参数个数不一致，而导致闭包中参数传递问题

**格式**

```python
def funcOut(func):
    """ 闭包的格式 """

    def funcIn(*args, **kwargs):
        # 这里调用其他函数
        func(args, kwargs)

    return funcIn
```

**测试**

```python
"""
    通用装饰器：解决不同函数的参数个数不同(通过可变参数实现)

"""


def add_new_fun():
    print("我是新功能哦！")


def funcOut(func):
    """ 通用装饰器"""

    def funcIn(*args, **kwargs):
        add_new_fun()
        func(*args, **kwargs)

    return funcIn


def funcOut1(func):
    """ 闭包函数 1"""

    def funcIn(x, y):
        add_new_fun()
        func(x, y)

    return funcIn


def funcOut2(func):
    """ 闭包函数 2"""

    def funcIn(x, y, z):
        add_new_fun()
        func(x, y, z)

    return funcIn


# @funcOut1
@funcOut
def func1(a, b):
    print("a={},b={}".format(a, b))


@funcOut
# @funcOut2
def func2(a, b, c):
    print("a={},b={},c={}".format(a, b, c))


if __name__ == '__main__':
    func1(1, 2)
    func2(1, 2, 3)

```

## Python 语言特性 ##

#### 动态添加属性 ####

动态语言：可以在运行时，改变类的结构，添加属性，添加方法，删除函数

强类型语言： 变量的类型，运行时决定。

​						变量的类型在运行之后， 可以任意变量，不需要强制转换

| 添加对象属性                  | 添加类属性 |
| ----------------------------- | ---------- |
| 对象名.属性                   | 类名.属性  |
| setattr(对象名, 属性, 属性名) |            |



```python
"""
    Python 是动态语言：
        可以动态地添加对象的属性、类属性、对象方法
    Python 也是强类型语言
"""


class Student:
    """ 学生类 """

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return "Student:name:{},age:{}".format(self.name, self.age)


if __name__ == '__main__':
    marry = Student('marry', 20)
    print(marry)
    """
        动态地增加对象的属性
    """
    # 方式1
    marry.score = 90
    print(marry, "score:{}".format(marry.score))
    # 方式2,通过 setattr 内置函数为 marry 对象设置 addr 属性，值为 安徽
    setattr(marry, 'addr', '安徽')
    print(marry, "address:{}".format(marry.addr))

    """
        动态地类属性
    """
    Student.clz = "七班"

    print("班级：%s" % Student.clz)


    """创建 tom 对象"""
    tom = Student("tom", 25)
    print(tom)

```

#### 动态添加方法 ####
| 添加方法           | 实现                                |
| ------------------ | ----------------------------------- |
| 添加对象(成员)方法 | `types.MethodType(函数名, 对象名)`  |
| 添加静态方法       | 类名.方法名 = 函数名  @staticmethod |
| 添加类方法         | 类名.方法名 = 函数名   @classmethod |

**注意： 函数名不要加括号**

```python
"""
    添加动态属性
    导入 types 库
"""

import types


class Student:
    """ 学生类 """

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return "Student:name:{},age:{}".format(self.name, self.age)


if __name__ == '__main__':
    tom = Student("tom", 24)

    """
        为对象绑定动态方法
    """


    def getName(self):
        return self.name


    # 将方法 getName 绑定到 tom 对象上
    tom.getName = types.MethodType(getName, tom)
    print("Name:{}".format(tom.getName()))

    """
        添加静态方法
    """


    @staticmethod
    def study():
        print("学习使我快乐， 我爱学习！")


    # 绑定静态方法
    Student.study = study
    # 调用静态方法
    tom.study()
    Student.study()

    """ 添加类方法"""


    @classmethod
    def playGame(cls):
        print("我爱游戏 ...")


    Student.playGame = playGame
    # 调类方法
    Student.playGame()

    """
        创建 marry 对象
    """
    marry = Student('marry', 25)
    marry.study()
    marry.playGame()
```

### `__slots__`的作用 ###

> 限制作用：对添加对象属性和方法有限制，但是对类属性和方法、静态方法以及子类没有限制

```
"""
    添加动态属性
    导入 types 库
"""

import types


class Student:
    """ 学生类 """
    __slots__ = ('name', 'age')

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return "Student:name:{},age:{}".format(self.name, self.age)


class LitteStudent(Student):
    pass


if __name__ == '__main__':
    tom = Student("tom", 24)

    # tom.score = 100 # 'Student' object has no attribute 'score'

    """
        为对象绑定动态方法
    """


    def getName(self):
        return self.name


    # 将方法 getName 绑定到 tom 对象上
    # tom.getName = types.MethodType(getName, tom)
    # print("Name:{}".format(tom.getName())) #'Student' object has no attribute 'getName'

    """
        添加静态方法
    """


    @staticmethod
    def study():
        print("学习使我快乐， 我爱学习！")


    # 绑定静态方法
    Student.study = study
    # 调用静态方法
    tom.study()
    Student.study()

    """ 添加类方法"""


    @classmethod
    def playGame(cls):
        print("我爱游戏 ...")


    Student.playGame = playGame
    # 调类方法
    Student.playGame()

    """
        创建 marry 对象
    """
    marry = Student('marry', 25)
    marry.study()
    marry.playGame()


    """
        創建 litteStudent 对象
    """
    lStudent = LitteStudent("小学生", 12)
    lStudent.score = 100
    lStudent.getName = types.MethodType(getName, lStudent)
    print(lStudent)
    print(lStudent.getName())
```

