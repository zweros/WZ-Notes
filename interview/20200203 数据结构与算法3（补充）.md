---
title: 20200203 数据结构与算法3
date: 2020-02-03
---

## 平衡树

### 分类

- 二叉搜索树

- AVL 树

- 2-3查找树
- 红黑树 RedBlackTree
- B 树
- B+ 树

### 树的生长方向

1. 自顶向下生长
   - 二叉搜索树
   - AVL 树
2. 自底向上生长
   - 2-3查找树
   - 红黑树 RedBlackTree
   - B 树
   - B+ 树

## 2-3 查找树

### 2-3 查找树的定义

- 2-结点：含有一个键（及其对应的值）和两个链，左链接指向 2-3 树中的键都小于该结点，右链接指向的 2-3 树中的键都大于该结点。
- 3-结点：含有两个键（及其对应的值）和三条链，左链接指向的 2-3 树中的键都小于该结点，中链接指向的 2-3 树中的键都位于该结点的两个键之间，右链接指向的 2-3 树中的键都大于该结点。

![](http://img.zwer.xyz/blog/20200203112718.png)

### **2-3 查找树的查找过程**

2-3 查找树的查找逻辑与二叉搜索树的查找逻辑类似。

比方说查找结点 V ，从根结点开始比较，若 V 的值小于根结点的值，则根结点的左子树查找，重复上面的步骤。若 V 的值大于根结点，则根结点的右子树查找，重复上面的步骤。若 V 的值等于根结点的值返回。

特殊的当遇到 3-结点的时候，需要最多需要比较的次数为 2 。查找结点先与 3-结点中左键做比较，若大于 3-结点左键的值，则与3-结点中右键做比较。若小于 3-节点左键的值，则从 3-结点的左边链查找。若等于 3-结点左键的值，则直接返回。右键的查找与左键相同。若查找结点的值大于 3-结点左键的值且小于 3-结点右键的值，则从3-结点的中间链表查找。

### **2-3 查找树插入新结点**

1. 向 2-结点中插入新键
2. 向一棵只含有一个 3- 结点的树中插入新键
3. 向一个父结点为 2-结点的 3-结点中插入新键
4. 向一个父结点为 3-结点的 3-结点中插入新键
5. 分解根结点

### **2-3 查找树的性质**

通过对 2-3 树插入操作的分析，我们发现在插入的时候， 2-3 树需要做一些局部的变换来保持 2-3 树的平衡。

一棵完全平衡的 2-3 树具有以下的性质：

1. 任意空链接到根结点的长度都是相等的。
2. 4-结点 变换为 3-结点时，树的高度不会发生变化，只有当根结点是临时的 4-结点，分解根结点时，树高+1。
3. 2-3 树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生成，而 2-3 树是自底向上生长。

### **2-3 查找树的实现**

2-3 查找树的实现比较麻烦，因为：

- 需要处理不同的结点类型，非常繁琐
- 需要多次比较操作来将结点下移
- 需要上移来拆分 4-结点
- 拆分 4-结点的情况有很多种

2-3 查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是 2-3 查找树作为一种比较重要的概念和思路对于红黑树、B 树和 B+树非常重要

## 红黑树

红黑树主要是对 2-3 树进行编码，红黑树背后的基本思想是用标椎的二叉查找树(完全由 2-结点构成)和一些额外的信息(替换 3-结点)来表示 2-3 树。我们将树中的链接分为两种类型：

**红链接：**将两个 2-结点连接起来构成一个 3-结点

**黑链接：**则是 2-3 树中的普通链接

确切的说，我们将 3-结点表示为由一条**左斜**的红色链接(两个 2-结点其中之一是另一个的左子结点)相连的两个 2-结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的 get 方法。

![](http://img.zwer.xyz/blog/20200203164513.png)

### **红黑树的定义**

红黑树是含有红黑链接并满足下列条件的二叉查找树：

1. 红链接均为左链接
2. 没有任何一个结点同时和两条红链接相接
3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同

下面是红黑树与 2-3 树的对应关系：

![](http://img.zwer.xyz/blog/20200203165146.png)

![](D:\photo\TyporaPicture\20200203165229.png)



### **红黑树结点 API**

因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的 Node 结点中添加一个布尔类型的变量 color 来表示链接的颜色。如果指向它的链接是红色的，那么该变量的值为 true，如果链接是黑色的，那么该变量的值为 false

![](http://img.zwer.xyz/blog/20200203170440.png)】、

API 设计：

| 类名     | Node                                                         |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key,Value value,Node left,Node right,boolean color) |
| 成员变量 | public Node left:记录左子结点<br />public Node right:记录右子结点<br />public Key key:存储键<br />public Value value: 存储值<br />public boolean color:由其父结点指向它的链接的颜色 |

### **红黑树平衡化**

对红黑树进行一些增删改查的操作后，很有可能出现**红色的右链或者两条连续红色的链接**，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。

- **左旋**

  当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋

  前提：当前结点为 h，它的右子结点为 x

  左旋过程：

  1. 让 x  的左子结点变为 h 的右子结点： h.right = x.left
  2. 让 h  成为 x 的左子结点： x.left = h
  3. 让 h 的 color 属性变为 x 的 color 属性值：x.color = h.color
  4. 让 h 的 color 属性变为 RED: h.color = true

  ![](http://img.zwer.xyz/blog/20200203171500.png)

  

- **右旋**

  当某个结点的左子结点是红色，且左子结点的左结点也是红色，需要右旋

  前提：当前结点为 h，它的左子结点为 x

  右旋过程：

  1. 让  x 的右子结点成为 h 的左子结点： h.left = x.right
  2. 让  h 成为 x 的右子结点：x.right = h
  3. 让 x 的 color 变为 h 的 color 属性值：x.color = h.color
  4. 让 h 的 color 为 RED

  ![](http://img.zwer.xyz/blog/20200203171403.png)

### 向单个 2-结点中插入新键

一棵只含有一个键的红黑树只含有一个 2-结点。插入另一个键后，我们马上就需要将他们旋转。

- 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个 3-结点完全等价

  ![](http://img.zwer.xyz/blog/20200203175219.png)、

- 如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把红色右链变成左链接，插入操作才算完成。形成的新的红黑树依然和 3-结点等价，其中含有两个键，一条红色链接

  ![](http://img.zwer.xyz/blog/20200203175856.png)

  

  

### 向底部的 2-结点插入新键

用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个 2-结点，那么上面的两种方式仍然适用。

![](http://img.zwer.xyz/blog/20200203175933.png)

### 颜色反转

当一个结点的左子结点和右子结点的 color 都为 RED 时，也就是出现了临时的 4-结点，此时只需要把左子结点和右子结点的颜色变为 BLACK,同时让当前节点的颜色变为 RED 即可。

![](http://img.zwer.xyz/blog/20200203180314.png)

### **向一棵双键树（即一个 3-结点）中插入新键**

这种情况有可以分为三种子情况

1. 新键大于原树中的两个键

   ![](http://img.zwer.xyz/blog/20200203180803.png)

   

2. 新键小于原树中的两个键

   ![](http://img.zwer.xyz/blog/20200203185656.png)

   ![](http://img.zwer.xyz/blog/20200203185745.png)

   

3. 新键位于原树中两个键中间

   ![](http://img.zwer.xyz/blog/20200203185908.png)

   ![](http://img.zwer.xyz/blog/20200203190340.png)

   

### **根结点的颜色总是黑色**

在结点 Node 对象中 color 属性表示的是父结点指向当前结点的连接的颜色，由于根结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。

### **向树底部的 3-结点插入新键**

假设在树的底部的一个 3-结点下加入一个新的结点。前面我们所讲的 3 种情况都会出现。指向新结点的链接可能是 3-结点的右链接（此时我们只需要转换颜色即可），或是左链接（此时我们需要进行右旋转然后再转换），或是中链接（此时需要先左旋转然后再右旋转，最后转换颜色）。颜色转换会使中间结点的颜色变红，相当于将它送入了父结点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个 2-结点或者根节点为止

![](http://img.zwer.xyz/blog/20200203190809.png)

![](http://img.zwer.xyz/blog/20200203192000.png)

![](http://img.zwer.xyz/blog/20200203192108.png)



### **红黑树的 API 设计**

![](http://img.zwer.xyz/blog/20200203192552.png)

### **红黑树的实现**

```java
package com.szxy.tree;

/**
 * @Author:zwer
 * @Date:2020/2/3 19:26
 * @Description:com.szxy.tree
 * @Version:1.0
 * 红黑树实现
 **/
public class RedBlackTree<Key extends Comparable<Key>,Value> {

    /**
     * 记录根节点
     */
    private Node root;

    /**
     *  记录树中元素的个数
     */
    private int N;

    /**
     * 记录父结点指向该链接为红色的
     */
    private static final boolean RED = true;

    /**
     * 记录父结点指向该链接为黑色的
     */
    private static final boolean BLACK = false;

    /**
     * 获取树中元素的个数
     * @return int
     */
    public int size(){
        return N;
    }

    /**
     * 判断当前结点的父结点指向链接是否为红色
     * @param x 当前结点
     * @return
     */
    private boolean isRed(Node x){
        if(x == null) return false;
        return x.color == RED;
    }

    /**
     * 左旋调整
     * @param h 当前结点
     * @return Node
     */
    private Node rotateLeft(Node h){
        // 保存当前结点 h 的右结点为 x
        Node x = h.right;
        // 将结点 x 的左子树挂在当前结点 h 的右节点上
        h.right = x.left;
        // 将当前结点 h 挂在结点 x 的左子树上
        x.left = h;
        // 将结点 x 的颜色等于结点 h
        x.color = h.color;
        // 将结点 h 的颜色设置 RED
        h.color = RED;
        return x;
    }

    /**
     * 右旋调整
     * @param h 当前结点
     * @return
     */
    private Node rotateRight(Node h){
        // 保存当前结点 h 的左结点 x
        Node x = h.left;
        // 将结点 x 的右子树挂在结点 h 的左结点上
        h.left = x.right;
        // 将结点 h 挂在结点 x 的右结点上
        x.right = h;
        // 将结点 x 的颜色等于结点 h
        x.color = h.color;
        // 将结点 h 的颜色设置 RED
        h.color = RED;
        return x;
    }

    /**
     * 颜色反转，相当于完成拆分 4-结点
     * @param h
     */
    private void flipColors(Node h){
        // 合法性校验
        if(h == null || h.left == null || h.right == null)  return;
        h.color = RED;
        h.left.color = h.right.color = BLACK;
    }

    /**
     * 在整个树上插入操作
     * @param key
     * @param val
     */
    public void put(Key key, Value val){
        root = put(root, key, val);
        // 根结点的颜色始终为黑色
        root.color = BLACK;
    }

    /**
     * 在指定树中，完成插入操作，并添加元素后新的树
     * @param h
     * @param key
     * @param val
     * @return
     */
    private Node put(Node h, Key key, Value val){
        if(h == null){
            N++; // 数量+1
            return new Node(key,val, null, null, RED);
        }

        // 将 h 与 key 进行比较
        int cmp =  key.compareTo(h.key);
        // 如果新键的值小于结点 h 的值
        if(cmp < 0){
            h.left = put(h.left, key, val);
        }else if(cmp > 0){// 如果新键的值大于结点 h 的值
            h.right = put(h.right,key,val);
        }else{
            h.value = val;
        }

        // 左旋：当前结点的右结点为红色时且当前结点的左结点为黑色
        if(isRed(h.right) && !isRed(h.left)){
            h = rotateLeft(h);
        }

        // 右旋：当前结点的左节点为红色且左节点的左节点也为红色
        if(isRed(h.left) && isRed(h.left.left)){
            h = rotateRight(h);
        }

        // 颜色反转：当前结点的左右结点都为红色
        if(isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }

        return h;
    }

    /**
     * 根据 key ，从树中找出对应的值
     * @param key
     * @return
     */
    public Value get(Key key){
        return get(root,key);
    }

    /**
     * 从指定的树 x 中，找出 key 对应的值
     * @param x
     * @param key
     * @return
     */
    private Value get(Node x, Key key){
        if( x == null)
            return null;
        // 比较结点 x 与 key 的大小
        int cmp = key.compareTo(x.key);
        if(cmp < 0){
            return get(x.left,key);
        }else if(cmp > 0){
            return get(x.right,key);
        }else{
            return  x.value;
        }
    }

    /**
     * 红黑树中的结点
     */
    private class Node{
        // 记录左结点
        private Node left;
        // 记录右结点
        private Node right;
        // 存储键
        private Key key;
        // 存储值
        private Value value;
        // 标识红黑树的颜色,由其父结点指向它链接的颜色
        private boolean color;

        public Node(Key key, Value value, Node left, Node right, boolean color){
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
        }
    }

}
```



## B 树

B 树一种树状数据结构，它能够存储数据，对其进行排序并允许以 $O(logN)$ 的时间复杂度进行查找、顺序读取、插入和删除等操作。

### B 树的特性

B 树中允许一个结点中包含多个 key ，可以是 3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数 M，来构造一个 B 树，我们可以把它称作是 M 阶的 B 树，那么该树会具有如下特点：

- 每个结点最多有 M-1 个 key，并且以升序排序
- 每个结点最多能有 M 个子结点
- 根结点至少有两个子结点

![](http://img.zwer.xyz/blog/20200203224121.png)

在实际应用中 B 树的阶数一般都比较大（通常大于 100），所以，即使存储大量的数据，B 树的高度仍然比较小，这样在某些应用场景下，就可以提现出它的优势。

### B 树存储数据

若参数 M 选择为 5，那么每个结点最多包含 4 个键值对，我们以 5 阶 B 树为例，看看 B 树的数据存储

![](http://img.zwer.xyz/blog/20200203224850.png)

![](http://img.zwer.xyz/blog/20200203225912.png)

### B 树在磁盘文件中的应用

在我们的程序中，不可避免的需要通过 IO 操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了 B 树这种数据结构

**磁盘**

磁盘能够保存大量的数据，从 GB 一直到 TB 级，但是它的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级

![](http://img.zwer.xyz/blog/20200203230159.png)



磁盘由盘片构成，每个盘片有两面，又称为盘面。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转，通常是 5400 RPM 或者是 7200 RPM，一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内。盘片的每个表面是由一组称为磁道同心圆组成的，每个磁道被划分了一组扇区，每个扇区包含相等数量的数据位，通常是 512个字节，扇区之间由一些间隙隔开，这些间隙中不存储数据。

**磁盘 IO**

![](http://img.zwer.xyz/blog/20200203231436.png)

![](http://img.zwer.xyz/blog/20200203231747.png)

## B+ 树

B+ 树是对 B 树的一种变形树，它与 B 树的差异在于

1. 非叶结点仅具有索引作用，也就是说，非叶子只存储 Key，不存储 Value
2. 树的所有叶结点构成一个有序链表，可以按照 Key 排序的次序遍历全部数据

### B+ 树存储数据

若参数 M 选择为 5，那么每个结点最多包含 4 个键值对，我们以 5 阶 B+树为例，看看 B+树的数据存储

![](http://img.zwer.xyz/blog/20200204104812.png)

![](http://img.zwer.xyz/blog/20200204105659.png)

### B+ 树和 B树的对比

**B+ 树的优点在于：**

1. 由于 B+ 树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的 key

2. B+ 树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而 B 树则需要进行每一层的递归遍历

**B 树的优点在于：**

由于 B 树的每个节点都包含 Key 和 Value，因此我们根据 Key 查找 Value 时，只需要找到 Key 所在的位置，就能找到 Value，但 B+ 树只有叶子结点存储数据，索引每一次 查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到 Value。



### B+ 树在数据库中的应用

在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题，在很多数据库中，都是用到了 B+ 树来提高查询的效率

在操作数据库时，我们我为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这个索引就是 B+ 树这种数据结构实现的。

1. 未建立主键索引查询

   ![](http://img.zwer.xyz/blog/20200204110631.png)

2. 建立主键索引查询

   ![](http://img.zwer.xyz/blog/20200204110834.png)

   

3. 区间查询

   执行 `select * from user where id >= 12 and id <= 18` ,如果有了索引，由于 B+树的叶子结点形成了一个有序链表，所以我们只需要找到 id 为 12 的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。



